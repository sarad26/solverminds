{"version":3,"sources":["../../src/ts/misc/animationFrameService.ts"],"names":[],"mappings":"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","file":"animationFrameService.js","sourcesContent":["\nimport { Autowired, Bean, PostConstruct } from \"../context/context\";\nimport { AnimationQueueEmptyEvent } from \"../events\";\nimport { Events } from \"../eventKeys\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { ControllersService } from \"../controllersService\";\n\ninterface TaskItem {\n    task: () => void;\n    index: number;\n    createOrder: number;\n}\n\ninterface TaskList {\n    list: TaskItem[];\n    sorted: boolean;\n}\n@Bean('animationFrameService')\nexport class AnimationFrameService extends BeanStub {\n\n    @Autowired('controllersService') private controllersService: ControllersService;\n\n    // p1 and p2 are create tasks are to do with row and cell creation.\n    // for them we want to execute according to row order, so we use\n    // TaskItem so we know what index the item is for.\n    private createTasksP1: TaskList = { list: [], sorted: false }; // eg drawing back-ground of rows\n    private createTasksP2: TaskList = { list: [], sorted: false }; // eg cell renderers, adding hover functionality\n\n    // destroy tasks are to do with row removal. they are done after row creation as the user will need to see new\n    // rows first (as blank is scrolled into view), when we remove the old rows (no longer in view) is not as\n    // important.\n    private destroyTasks: (() => void)[] = [];\n    private ticking = false;\n    private useAnimationFrame: boolean;\n\n    // we need to know direction of scroll, to build up rows in the direction of\n    // the scroll. eg if user scrolls down, we extend the rows by building down.\n    private scrollGoingDown = true;\n    private lastScrollTop = 0;\n\n    private taskCount = 0;\n    private cancelledTasks = new Set();\n\n    public setScrollTop(scrollTop: number): void {\n        this.scrollGoingDown = scrollTop > this.lastScrollTop;\n        this.lastScrollTop = scrollTop;\n    }\n\n    @PostConstruct\n    private init(): void {\n        this.useAnimationFrame = !this.gridOptionsWrapper.isSuppressAnimationFrame();\n    }\n\n    // this method is for our AG Grid sanity only - if animation frames are turned off,\n    // then no place in the code should be looking to add any work to be done in animation\n    // frames. this stops bugs - where some code is asking for a frame to be executed\n    // when it should not.\n    private verifyAnimationFrameOn(methodName: string): void {\n        if (this.useAnimationFrame === false) {\n            console.warn(`AG Grid: AnimationFrameService.${methodName} called but animation frames are off`);\n        }\n    }\n\n    public createTask(task: () => void, index: number, list: 'createTasksP1' | 'createTasksP2') {\n        this.verifyAnimationFrameOn(list);\n        const taskItem: TaskItem = { task, index, createOrder: ++this.taskCount };\n        this.addTaskToList(this[list], taskItem);\n        this.schedule();\n    }\n\n    public cancelTask(task: () => void) {\n        this.cancelledTasks.add(task);\n    }\n\n    private addTaskToList(taskList: TaskList, task: TaskItem): void {\n        taskList.list.push(task);\n        taskList.sorted = false;\n    }\n\n    private sortTaskList(taskList: TaskList) {\n        if (taskList.sorted) { return; }\n\n        const sortDirection = this.scrollGoingDown ? 1 : -1;\n\n        // sort first by row index (taking into account scroll direction), then by\n        // order of task creation (always ascending, so cells will render left-to-right)\n        taskList.list.sort((a, b) => a.index !== b.index ? sortDirection * (b.index - a.index) : b.createOrder - a.createOrder);\n        taskList.sorted = true;\n    }\n\n    public addDestroyTask(task: () => void): void {\n        this.verifyAnimationFrameOn('createTasksP3');\n        this.destroyTasks.push(task);\n        this.schedule();\n    }\n\n    private executeFrame(millis: number): void {\n        this.verifyAnimationFrameOn('executeFrame');\n\n        const p1TaskList = this.createTasksP1;\n        const p1Tasks = p1TaskList.list;\n\n        const p2TaskList = this.createTasksP2;\n        const p2Tasks = p2TaskList.list;\n\n        const destroyTasks = this.destroyTasks;\n\n        const frameStart = new Date().getTime();\n        let duration = (new Date().getTime()) - frameStart;\n\n        // 16ms is 60 fps\n        const noMaxMillis = millis <= 0;\n\n        const gridBodyCon = this.controllersService.getGridBodyController();\n\n        while (noMaxMillis || duration < millis) {\n            const gridBodyDidSomething = gridBodyCon.getScrollFeature().executeAnimationFrameScroll();\n\n            if (!gridBodyDidSomething) {\n                let task: () => void;\n                if (p1Tasks.length) {\n                    this.sortTaskList(p1TaskList);\n                    task = p1Tasks.pop()!.task;\n                } else if (p2Tasks.length) {\n                    this.sortTaskList(p2TaskList);\n                    task = p2Tasks.pop()!.task;\n                } else if (destroyTasks.length) {\n                    task = destroyTasks.pop()!;\n                } else {\n                    this.cancelledTasks.clear();\n                    break;\n                }\n\n                if (!this.cancelledTasks.has(task)) {\n                    task();\n                }\n            }\n\n            duration = (new Date().getTime()) - frameStart;\n        }\n\n        if (p1Tasks.length || p2Tasks.length || destroyTasks.length) {\n            this.requestFrame();\n        } else {\n            this.stopTicking();\n        }\n    }\n\n    private stopTicking(): void {\n        this.ticking = false;\n        const event: AnimationQueueEmptyEvent = {\n            type: Events.EVENT_ANIMATION_QUEUE_EMPTY,\n            columnApi: this.gridOptionsWrapper.getColumnApi()!,\n            api: this.gridOptionsWrapper.getApi()!\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public flushAllFrames(): void {\n        if (!this.useAnimationFrame) { return; }\n        this.executeFrame(-1);\n    }\n\n    public schedule(): void {\n        if (!this.useAnimationFrame) { return; }\n        if (!this.ticking) {\n            this.ticking = true;\n            this.requestFrame();\n        }\n    }\n\n    private requestFrame(): void {\n        // check for the existence of requestAnimationFrame, and if\n        // it's missing, then we polyfill it with setTimeout()\n        const callback = this.executeFrame.bind(this, 60);\n        if (window.requestAnimationFrame) {\n            window.requestAnimationFrame(callback);\n        } else if (window.webkitRequestAnimationFrame) {\n            window.webkitRequestAnimationFrame(callback);\n        } else {\n            window.setTimeout(callback, 0);\n        }\n    }\n\n    public isQueueEmpty(): boolean {\n        return !this.ticking;\n    }\n\n}\n"]}