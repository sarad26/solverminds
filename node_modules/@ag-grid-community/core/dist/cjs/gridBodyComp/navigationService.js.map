{"version":3,"sources":["../../src/ts/gridBodyComp/navigationService.ts"],"names":[],"mappings":"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","file":"navigationService.js","sourcesContent":["import { Autowired, Bean, Optional, PostConstruct } from \"../context/context\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { MouseEventService } from \"./mouseEventService\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { Column } from \"../entities/column\";\nimport { FocusController } from \"../focusController\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { IRangeController } from \"../interfaces/iRangeController\";\nimport { ColumnController } from \"../columnController/columnController\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { exists } from \"../utils/generic\";\nimport { last } from \"../utils/array\";\nimport { KeyCode } from '../constants/keyCode';\nimport { ControllersService } from \"../controllersService\";\nimport { GridBodyController } from \"./gridBodyController\";\n\ninterface NavigateParams {\n     // The rowIndex to vertically scroll to\n    scrollIndex: number;\n     // The position to put scroll index\n    scrollType: 'top' | 'bottom' | null;\n    //  The column to horizontally scroll to\n    scrollColumn: Column | null;\n    // For page up/down, we want to scroll to one row/column but focus another (ie. scrollRow could be stub).\n    focusIndex: number;\n    focusColumn: Column;\n}\n\n@Bean('navigationService')\nexport class NavigationService extends BeanStub {\n\n    @Autowired('mouseEventService') private mouseEventService: MouseEventService;\n    @Autowired('paginationProxy') private paginationProxy: PaginationProxy;\n    @Autowired('focusController') private focusController: FocusController;\n    @Autowired('animationFrameService') private animationFrameService: AnimationFrameService;\n    @Optional('rangeController') private rangeController: IRangeController;\n    @Autowired('columnController') private columnController: ColumnController;\n    @Autowired('controllersService') public controllersService: ControllersService;\n\n    private gridBodyCon: GridBodyController;\n\n    private timeLastPageEventProcessed = 0;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.controllersService.whenReady(p => {\n            this.gridBodyCon = p.gridBodyCon;\n        });\n    }\n\n    public handlePageScrollingKey(event: KeyboardEvent): boolean {\n        const key = event.which || event.keyCode;\n        const alt = event.altKey;\n        const ctrl = event.ctrlKey || event.metaKey;\n\n        const currentCell: CellPosition | null = this.mouseEventService.getCellPositionForEvent(event);\n        if (!currentCell) { return false; }\n\n        let processed = false;\n\n        switch (key) {\n            case KeyCode.PAGE_HOME:\n            case KeyCode.PAGE_END:\n                // handle home and end when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onHomeOrEndKey(key);\n                    processed = true;\n                }\n                break;\n            case KeyCode.LEFT:\n            case KeyCode.RIGHT:\n                // handle left and right when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlLeftOrRight(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.UP:\n            case KeyCode.DOWN:\n                // handle up and down when ctrl is pressed only\n                if (ctrl && !alt) {\n                    this.onCtrlUpOrDown(key, currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_DOWN:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageDown(currentCell);\n                    processed = true;\n                }\n                break;\n            case KeyCode.PAGE_UP:\n                // handle page up and page down when ctrl & alt are NOT pressed\n                if (!ctrl && !alt) {\n                    this.onPageUp(currentCell);\n                    processed = true;\n                }\n                break;\n        }\n\n        if (processed) {\n            event.preventDefault();\n        }\n\n        return processed;\n    }\n\n    // the page up/down keys caused a problem, in that if the user\n    // held the page up/down key down, lots of events got generated,\n    // which clogged up the event queue (as they take time to process)\n    // which in turn froze the grid. Logic below makes sure we wait 100ms\n    // between processing the page up/down events, so when user has finger\n    // held down on key, we ignore page up/down events until 100ms has passed,\n    // which effectively empties the queue of page up/down events.\n    private isTimeSinceLastPageEventToRecent(): boolean {\n        const now = new Date().getTime();\n        const diff = now - this.timeLastPageEventProcessed;\n\n        return (diff < 100);\n    }\n\n    private setTimeLastPageEventProcessed(): void {\n        this.timeLastPageEventProcessed = new Date().getTime();\n    }\n\n    private navigateTo(navigateParams: NavigateParams): void {\n        const { scrollIndex, scrollType, scrollColumn, focusIndex, focusColumn } = navigateParams;\n\n        if (exists(scrollColumn)) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(scrollColumn);\n        }\n\n        if (exists(scrollIndex)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(scrollIndex, scrollType);\n        }\n\n        // make sure the cell is rendered, needed if we are to focus\n        this.animationFrameService.flushAllFrames();\n\n        // if we don't do this, the range will be left on the last cell, which will leave the last focused cell\n        // highlighted.\n        this.focusController.setFocusedCell(focusIndex, focusColumn, null, true);\n\n        if (this.rangeController) {\n            const cellPosition: CellPosition = { rowIndex: focusIndex, rowPinned: null, column: focusColumn };\n            this.rangeController.setRangeToCell(cellPosition);\n        }\n    }\n\n    private onPageDown(gridCell: CellPosition): void {\n        if (this.isTimeSinceLastPageEventToRecent()) { return; }\n\n        const gridBodyCon = this.controllersService.getGridBodyController();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        const scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n        if (this.controllersService.getCenterRowContainerCon().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n\n        const currentPageBottomPixel = scrollPosition.top + pixelsInOnePage;\n        const currentPageBottomRow = this.paginationProxy.getRowIndexAtPixel(currentPageBottomPixel + pagingPixelOffset);\n        let scrollIndex = currentPageBottomRow;\n\n        const currentCellPixel = this.paginationProxy.getRow(gridCell.rowIndex)!.rowTop;\n        const nextCellPixel = currentCellPixel! + pixelsInOnePage - pagingPixelOffset;\n        let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n\n        const pageLastRow = this.paginationProxy.getPageLastRow();\n\n        if (focusIndex > pageLastRow) { focusIndex = pageLastRow; }\n        if (scrollIndex > pageLastRow) { scrollIndex = pageLastRow; }\n\n        this.navigateTo({\n            scrollIndex,\n            scrollType: 'top',\n            scrollColumn: null,\n            focusIndex,\n            focusColumn: gridCell.column\n        });\n\n        this.setTimeLastPageEventProcessed();\n    }\n\n    private onPageUp(gridCell: CellPosition): void {\n        if (this.isTimeSinceLastPageEventToRecent()) { return; }\n\n        const gridBodyCon = this.controllersService.getGridBodyController();\n        const scrollPosition = gridBodyCon.getScrollFeature().getVScrollPosition();\n        const scrollbarWidth = this.gridOptionsWrapper.getScrollbarWidth();\n        let pixelsInOnePage = scrollPosition.bottom - scrollPosition.top;\n\n        if (this.controllersService.getCenterRowContainerCon().isHorizontalScrollShowing()) {\n            pixelsInOnePage -= scrollbarWidth;\n        }\n\n        const pagingPixelOffset = this.paginationProxy.getPixelOffset();\n\n        const currentPageTopPixel = scrollPosition.top;\n        const currentPageTopRow = this.paginationProxy.getRowIndexAtPixel(currentPageTopPixel + pagingPixelOffset);\n        let scrollIndex = currentPageTopRow;\n\n        const currentRowNode = this.paginationProxy.getRow(gridCell.rowIndex)!;\n        const nextCellPixel = currentRowNode.rowTop! + currentRowNode.rowHeight! - pixelsInOnePage - pagingPixelOffset;\n        let focusIndex = this.paginationProxy.getRowIndexAtPixel(nextCellPixel + pagingPixelOffset);\n\n        const firstRow = this.paginationProxy.getPageFirstRow();\n\n        if (focusIndex < firstRow) { focusIndex = firstRow; }\n        if (scrollIndex < firstRow) { scrollIndex = firstRow; }\n\n        this.navigateTo({\n            scrollIndex,\n            scrollType: 'bottom',\n            scrollColumn: null,\n            focusIndex,\n            focusColumn: gridCell.column\n        });\n\n        this.setTimeLastPageEventProcessed();\n    }\n\n    private getIndexToFocus(indexToScrollTo: number, isDown: boolean) {\n        let indexToFocus = indexToScrollTo;\n\n        // for SSRM, when user hits ctrl+down, we can end up trying to focus the loading row.\n        // instead we focus the last row with data instead.\n        if (isDown) {\n            const node = this.paginationProxy.getRow(indexToScrollTo);\n            if (node && node.stub) {\n                indexToFocus -= 1;\n            }\n        }\n\n        return indexToFocus;\n    }\n\n    // ctrl + up/down will bring focus to same column, first/last row. no horizontal scrolling.\n    private onCtrlUpOrDown(key: number, gridCell: CellPosition): void {\n        const upKey = key === KeyCode.UP;\n        const rowIndexToScrollTo = upKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n\n        this.navigateTo({\n            scrollIndex: rowIndexToScrollTo,\n            scrollType: null,\n            scrollColumn: gridCell.column,\n            focusIndex: this.getIndexToFocus(rowIndexToScrollTo, !upKey),\n            focusColumn: gridCell.column\n        });\n    }\n\n    // ctrl + left/right will bring focus to same row, first/last cell. no vertical scrolling.\n    private onCtrlLeftOrRight(key: number, gridCell: CellPosition): void {\n        const leftKey = key === KeyCode.LEFT;\n        const allColumns: Column[] = this.columnController.getAllDisplayedColumns();\n        const columnToSelect: Column = leftKey ? allColumns[0] : last(allColumns);\n\n        this.navigateTo({\n            scrollIndex: gridCell.rowIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: gridCell.rowIndex,\n            focusColumn: columnToSelect\n        });\n    }\n\n    // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring\n    // same cell into view (which means either scroll all the way up, or all the way down).\n    private onHomeOrEndKey(key: number): void {\n        const homeKey = key === KeyCode.PAGE_HOME;\n        const allColumns: Column[] = this.columnController.getAllDisplayedColumns();\n        const columnToSelect = homeKey ? allColumns[0] : last(allColumns);\n        const scrollIndex = homeKey ? this.paginationProxy.getPageFirstRow() : this.paginationProxy.getPageLastRow();\n\n        this.navigateTo({\n            scrollIndex: scrollIndex,\n            scrollType: null,\n            scrollColumn: columnToSelect,\n            focusIndex: this.getIndexToFocus(scrollIndex, !homeKey),\n            focusColumn: columnToSelect\n        });\n    }\n}\n"]}