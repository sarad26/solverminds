{"version":3,"sources":["../../src/ts/rowNodes/rowNodeSorter.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAEA,8CAAqD;AAGrD,kCAA6B;AAC7B,oDAAmD;AAYnD,2CAA2C;AAG3C;IAAA;IAiDA,CAAC;IA5CU,kCAAU,GAAjB,UAAkB,QAAmB,EAAE,WAAyB;QAE5D,IAAM,MAAM,GAAG,UAAC,OAAgB,EAAE,GAAW,IAAK,OAAA,CAAC,EAAC,UAAU,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,EAAC,CAAC,EAArC,CAAqC,CAAC;QACxF,IAAM,cAAc,GAAoB,QAAQ,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAE7D,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;QAElE,OAAO,cAAc,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,CAAC,OAAO,EAAZ,CAAY,CAAC,CAAC;IACpD,CAAC;IAEM,uCAAe,GAAtB,UAAuB,WAAyB,EAAE,WAA0B,EAAE,WAA0B;QACpG,IAAM,KAAK,GAAY,WAAW,CAAC,OAAO,CAAC;QAC3C,IAAM,KAAK,GAAY,WAAW,CAAC,OAAO,CAAC;QAE3C,uDAAuD;QACvD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;YACpD,IAAM,UAAU,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC;YAClC,uFAAuF;YAEvF,IAAM,UAAU,GAAG,UAAU,CAAC,IAAI,KAAK,qBAAS,CAAC,SAAS,CAAC;YAC3D,IAAM,MAAM,GAAQ,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;YAC5D,IAAM,MAAM,GAAQ,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,UAAU,CAAC,MAAM,CAAC,CAAC;YAC5D,IAAI,gBAAgB,SAAQ,CAAC;YAC7B,IAAM,kBAAkB,GAAG,UAAU,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,UAAU,CAAC;YACpE,IAAI,kBAAkB,EAAE;gBACpB,gCAAgC;gBAChC,gBAAgB,GAAG,kBAAkB,CAAC,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,CAAC,CAAC;aACnF;iBAAM;gBACH,iCAAiC;gBACjC,gBAAgB,GAAG,SAAC,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,kBAAkB,CAAC,cAAc,EAAE,CAAC,CAAC;aACpG;YAED,IAAI,gBAAgB,KAAK,CAAC,EAAE;gBACxB,OAAO,UAAU,CAAC,IAAI,KAAK,qBAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,gBAAgB,GAAG,CAAC,CAAC,CAAC;aAC5F;SACJ;QACD,mEAAmE;QACnE,OAAO,WAAW,CAAC,UAAU,GAAG,WAAW,CAAC,UAAU,CAAC;IAC3D,CAAC;IAEO,gCAAQ,GAAhB,UAAiB,KAAc,EAAE,MAAc;QAC3C,OAAO,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;IACrD,CAAC;IA7CgC;QAAhC,mBAAS,CAAC,oBAAoB,CAAC;6DAAgD;IACrD;QAA1B,mBAAS,CAAC,cAAc,CAAC;uDAAoC;IAHrD,aAAa;QADzB,cAAI,CAAC,eAAe,CAAC;OACT,aAAa,CAiDzB;IAAD,oBAAC;CAjDD,AAiDC,IAAA;AAjDY,sCAAa","file":"rowNodeSorter.js","sourcesContent":["import { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport { Autowired, Bean } from \"../context/context\";\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { ValueService } from \"../valueService/valueService\";\nimport { _ } from \"../utils\";\nimport { Constants } from \"../constants/constants\";\n\nexport interface SortOption {\n    sort: string;\n    column: Column;\n}\n\nexport interface SortedRowNode {\n    currentPos: number;\n    rowNode: RowNode;\n}\n\n// this logic is used by both SSRM and CSRM\n\n@Bean('rowNodeSorter')\nexport class RowNodeSorter {\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper: GridOptionsWrapper;\n    @Autowired('valueService') private valueService: ValueService;\n\n    public doFullSort(rowNodes: RowNode[], sortOptions: SortOption[]): RowNode[] {\n\n        const mapper = (rowNode: RowNode, pos: number) => ({currentPos: pos, rowNode: rowNode});\n        const sortedRowNodes: SortedRowNode[] = rowNodes.map(mapper);\n\n        sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));\n\n        return sortedRowNodes.map(item => item.rowNode);\n    }\n\n    public compareRowNodes(sortOptions: SortOption[], sortedNodeA: SortedRowNode, sortedNodeB: SortedRowNode): number {\n        const nodeA: RowNode = sortedNodeA.rowNode;\n        const nodeB: RowNode = sortedNodeB.rowNode;\n\n        // Iterate columns, return the first that doesn't match\n        for (let i = 0, len = sortOptions.length; i < len; i++) {\n            const sortOption = sortOptions[i];\n            // let compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);\n\n            const isInverted = sortOption.sort === Constants.SORT_DESC;\n            const valueA: any = this.getValue(nodeA, sortOption.column);\n            const valueB: any = this.getValue(nodeB, sortOption.column);\n            let comparatorResult: number;\n            const providedComparator = sortOption.column.getColDef().comparator;\n            if (providedComparator) {\n                //if comparator provided, use it\n                comparatorResult = providedComparator(valueA, valueB, nodeA, nodeB, isInverted);\n            } else {\n                //otherwise do our own comparison\n                comparatorResult = _.defaultComparator(valueA, valueB, this.gridOptionsWrapper.isAccentedSort());\n            }\n\n            if (comparatorResult !== 0) {\n                return sortOption.sort === Constants.SORT_ASC ? comparatorResult : comparatorResult * -1;\n            }\n        }\n        // All matched, we make is so that the original sort order is kept:\n        return sortedNodeA.currentPos - sortedNodeB.currentPos;\n    }\n\n    private getValue(nodeA: RowNode, column: Column): string {\n        return this.valueService.getValue(column, nodeA);\n    }\n\n}"]}