{"version":3,"sources":["../../src/ts/widgets/managedFocusComponent.ts"],"names":[],"mappings":"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","file":"managedFocusComponent.js","sourcesContent":["import { PostConstruct, Autowired } from '../context/context';\nimport { Component } from './component';\nimport { FocusController } from '../focusController';\nimport { isNodeOrElement, addCssClass, clearElement } from '../utils/dom';\nimport { KeyCode } from '../constants/keyCode';\nimport { isStopPropagationForAgGrid, stopPropagationForAgGrid } from '../utils/event';\n\n/**\n * This provides logic to override the default browser focus logic.\n *\n * When the component gets focus, it uses the grid logic to find out what should be focused,\n * and then focuses that instead.\n *\n * This is how we ensure when user tabs into the relevant section, we focus the correct item.\n * For example GridCore extends ManagedFocusComponent, and it ensures when it receives focus\n * that focus goes to the first cell of the first header row.\n */\nexport class ManagedFocusComponent extends Component {\n\n    protected handleKeyDown?(e: KeyboardEvent): void;\n\n    public static FOCUS_MANAGED_CLASS = 'ag-focus-managed';\n\n    private topTabGuard: HTMLElement;\n    private bottomTabGuard: HTMLElement;\n    private skipTabGuardFocus: boolean = false;\n\n    @Autowired('focusController') protected readonly focusController: FocusController;\n\n    /*\n     * Set isFocusableContainer to true if this component will contain multiple focus-managed\n     * elements within. When set to true, this component will add tabGuards that will be responsible\n     * for receiving focus from outside and focusing an internal element using the focusInnerElementMethod\n     */\n    constructor(template?: string, private readonly isFocusableContainer = false) {\n        super(template);\n    }\n\n    @PostConstruct\n    protected postConstruct(): void {\n        const focusableElement = this.getFocusableElement();\n\n        if (!focusableElement) { return; }\n\n        addCssClass(focusableElement, ManagedFocusComponent.FOCUS_MANAGED_CLASS);\n\n        if (this.isFocusableContainer) {\n            this.topTabGuard = this.createTabGuard('top');\n            this.bottomTabGuard = this.createTabGuard('bottom');\n            this.addTabGuards();\n            this.activateTabGuards();\n            this.forEachTabGuard(guard => this.addManagedListener(guard, 'focus', this.onFocus.bind(this)));\n        }\n\n        this.addKeyDownListeners(focusableElement);\n\n        this.addManagedListener(focusableElement, 'focusin', this.onFocusIn.bind(this));\n        this.addManagedListener(focusableElement, 'focusout', this.onFocusOut.bind(this));\n    }\n\n    /*\n     * Override this method if focusing the default element requires special logic.\n     */\n    protected focusInnerElement(fromBottom = false): void {\n        const focusable = this.focusController.findFocusableElements(this.getFocusableElement());\n\n        if (this.isFocusableContainer && this.tabGuardsAreActive()) {\n            // remove tab guards from this component from list of focusable elements\n            focusable.splice(0, 1);\n            focusable.splice(focusable.length - 1, 1);\n        }\n\n        if (!focusable.length) { return; }\n\n        focusable[fromBottom ? focusable.length - 1 : 0].focus();\n    }\n\n    /**\n     * By default this will tab though the elements in the default order. Override if you require special logic.\n     */\n    protected onTabKeyDown(e: KeyboardEvent) {\n        if (e.defaultPrevented) { return; }\n\n        const tabGuardsAreActive = this.tabGuardsAreActive();\n\n        if (this.isFocusableContainer && tabGuardsAreActive) {\n            this.deactivateTabGuards();\n        }\n\n        const nextRoot = this.focusController.findNextFocusableElement(this.getFocusableElement(), false, e.shiftKey);\n\n        if (this.isFocusableContainer && tabGuardsAreActive) {\n            // ensure the tab guards are only re-instated once the event has finished processing, to avoid the browser\n            // tabbing to the tab guard from inside the component\n            setTimeout(() => this.activateTabGuards(), 0);\n        }\n\n        if (!nextRoot) { return; }\n\n        nextRoot.focus();\n        e.preventDefault();\n    }\n\n    protected onFocusIn(e: FocusEvent): void {\n        if (this.isFocusableContainer) {\n            this.deactivateTabGuards();\n        }\n    }\n\n    protected onFocusOut(e: FocusEvent): void {\n        if (this.isFocusableContainer && !this.getFocusableElement().contains(e.relatedTarget as HTMLElement)) {\n            this.activateTabGuards();\n        }\n    }\n\n    public forceFocusOutOfContainer(up = false): void {\n        if (!this.isFocusableContainer) { return; }\n\n        this.activateTabGuards();\n        this.skipTabGuardFocus = true;\n\n        const tabGuardToFocus = up ? this.topTabGuard : this.bottomTabGuard;\n\n        if (tabGuardToFocus) { tabGuardToFocus.focus(); }\n    }\n\n    public appendChild(newChild: HTMLElement | Component, container?: HTMLElement): void {\n        if (this.isFocusableContainer) {\n            if (!isNodeOrElement(newChild)) {\n                newChild = (newChild as Component).getGui();\n            }\n\n            const { bottomTabGuard } = this;\n\n            if (bottomTabGuard) {\n                bottomTabGuard.insertAdjacentElement('beforebegin', newChild as HTMLElement);\n            } else {\n                super.appendChild(newChild, container);\n            }\n        } else {\n            super.appendChild(newChild, container);\n        }\n    }\n\n    private createTabGuard(side: 'top' | 'bottom'): HTMLElement {\n        const tabGuard = document.createElement('div');\n\n        tabGuard.classList.add('ag-tab-guard');\n        tabGuard.classList.add(`ag-tab-guard-${side}`);\n        tabGuard.setAttribute('role', 'presentation');\n\n        return tabGuard;\n    }\n\n    private addTabGuards(): void {\n        const focusableEl = this.getFocusableElement();\n\n        focusableEl.insertAdjacentElement('afterbegin', this.topTabGuard);\n        focusableEl.insertAdjacentElement('beforeend', this.bottomTabGuard);\n    }\n\n    private forEachTabGuard(callback: (tabGuard: HTMLElement) => void) {\n        if (this.topTabGuard) { callback(this.topTabGuard); }\n        if (this.bottomTabGuard) { callback(this.bottomTabGuard); }\n    }\n\n    private addKeyDownListeners(eGui: HTMLElement): void {\n        this.addManagedListener(eGui, 'keydown', (e: KeyboardEvent) => {\n            if (e.defaultPrevented || isStopPropagationForAgGrid(e)) { return; }\n\n            if (this.shouldStopEventPropagation(e)) {\n                stopPropagationForAgGrid(e);\n                return;\n            }\n\n            if (e.keyCode === KeyCode.TAB) {\n                this.onTabKeyDown(e);\n            } else if (this.handleKeyDown) {\n                this.handleKeyDown(e);\n            }\n        });\n    }\n\n    protected shouldStopEventPropagation(e: KeyboardEvent): boolean {\n        return false;\n    }\n\n    private onFocus(e: FocusEvent): void {\n        if (this.skipTabGuardFocus) {\n            this.skipTabGuardFocus = false;\n            return;\n        }\n\n        this.focusInnerElement(e.target === this.bottomTabGuard);\n    }\n\n    private activateTabGuards(): void {\n        this.forEachTabGuard(guard => guard.setAttribute('tabIndex', this.gridOptionsWrapper.getGridTabIndex()));\n    }\n\n    private deactivateTabGuards(): void {\n        this.forEachTabGuard(guard => guard.removeAttribute('tabIndex'));\n    }\n\n    private tabGuardsAreActive(): boolean {\n        return !!this.topTabGuard && this.topTabGuard.hasAttribute('tabIndex');\n    }\n\n    protected clearGui(): void {\n        const tabGuardsAreActive = this.tabGuardsAreActive();\n\n        clearElement(this.getFocusableElement());\n\n        if (this.isFocusableContainer) {\n            this.addTabGuards();\n\n            if (tabGuardsAreActive) {\n                this.activateTabGuards();\n            }\n        }\n    }\n}\n"]}