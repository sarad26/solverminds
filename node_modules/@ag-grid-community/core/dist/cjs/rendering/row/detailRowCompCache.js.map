{"version":3,"sources":["../../src/ts/rendering/row/detailRowCompCache.ts"],"names":[],"mappings":"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","file":"detailRowCompCache.js","sourcesContent":["import { ICellRendererComp } from \"../cellRenderers/iCellRenderer\";\nimport { RowNode } from \"../../entities/rowNode\";\nimport { Bean, PostConstruct, PreDestroy } from \"../../context/context\";\nimport { Constants } from \"../../constants/constants\";\nimport { BeanStub } from \"../../context/beanStub\";\n\n/**\n * For Master Detail, it is required to keep components between expanding & collapsing parents.\n * For example a user expands row A (and shows a detail grid for this row), then when row A\n * is closed, we want to keep the detail grid, so next time row A is expanded the detail grid\n * is showed with it's context intact, eg if user sorted in the detail grid, that sort should\n * still be applied after the detail grid is shown for the second time.\n */\n@Bean('detailRowCompCache')\nexport class DetailRowCompCache extends BeanStub {\n\n    private cacheItems: CacheItem[] = [];\n    private maxCacheSize: number | undefined;\n    private active: boolean;\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.active = this.gridOptionsWrapper.isKeepDetailRows();\n        this.maxCacheSize = this.gridOptionsWrapper.getKeepDetailRowsCount();\n    }\n\n    public addOrDestroy(rowNode: RowNode, pinned: string | null, comp: ICellRendererComp): void {\n        // only accept detail rows\n        const doNotUseCache = !this.active || !rowNode.detail;\n        if (doNotUseCache) {\n            this.destroyFullWidthRow(comp);\n            return;\n        }\n\n        const item = this.getCacheItem(rowNode, true)!;\n\n        // put the comp in the right location of the item.\n        // we also destroy any previous comp - this should never happen\n        // as the logic outside of this class shouldn't be adding same item to the\n        // cache twice, however we cater for it in case in future releases code\n        // outside of this class is changed and this could happen.\n        switch (pinned) {\n            case Constants.PINNED_LEFT:\n                this.destroyFullWidthRow(item.left!);\n                item.left = comp;\n                break;\n            case Constants.PINNED_RIGHT:\n                this.destroyFullWidthRow(item.right!);\n                item.right = comp;\n                break;\n            default:\n                this.destroyFullWidthRow(item.center!);\n                item.center = comp;\n                break;\n        }\n\n        this.cacheItems.sort((a: CacheItem, b: CacheItem) => {\n            return b.lastAccessedTime - a.lastAccessedTime;\n        });\n        this.purgeCache(this.maxCacheSize!);\n    }\n\n    private getCacheItem(rowNode: RowNode, autoCreate = false): CacheItem | null {\n        let res: CacheItem | null = null;\n\n        for (let i = 0; i < this.cacheItems.length; i++) {\n            const item = this.cacheItems[i];\n            if (item.rowNode === rowNode) {\n                res = item;\n                break;\n            }\n        }\n\n        if (!res && autoCreate) {\n            res = {\n                rowNode: rowNode\n            } as CacheItem;\n            this.cacheItems.push(res);\n        }\n\n        if (res) {\n            this.stampCacheItem(res);\n        }\n\n        return res;\n    }\n\n    private stampCacheItem(item: CacheItem) {\n        item.lastAccessedTime = new Date().getTime();\n    }\n\n    private destroyFullWidthRow(comp: ICellRendererComp): void {\n        this.getContext().destroyBean(comp);\n    }\n\n    private purgeCache(startIndex: number): void {\n        // delete all rows past the index of interest\n        for (let i = startIndex; i < this.cacheItems.length; i++) {\n            const item = this.cacheItems[i];\n            this.destroyFullWidthRow(item.center!);\n            this.destroyFullWidthRow(item.left!);\n            this.destroyFullWidthRow(item.right!);\n        }\n\n        // change the length of the array so it no longer contains the deleted items\n        if (this.cacheItems.length > startIndex) {\n            this.cacheItems.length = startIndex;\n        }\n    }\n\n    public get(rowNode: RowNode, pinned: string | null): ICellRendererComp | undefined {\n        if (!rowNode.detail) { return; }\n\n        const item = this.getCacheItem(rowNode);\n        let res: ICellRendererComp | undefined;\n\n        if (item) {\n            switch (pinned) {\n                case Constants.PINNED_LEFT:\n                    if (item.left) {\n                        res = item.left;\n                        item.left = undefined;\n                    }\n                    break;\n                case Constants.PINNED_RIGHT:\n                    if (item.right) {\n                        res = item.right;\n                        item.right = undefined;\n                    }\n                    break;\n                default:\n                    if (item.center) {\n                        res = item.center;\n                        item.center = undefined;\n                    }\n                    break;\n            }\n        }\n        return res;\n    }\n\n    @PreDestroy\n    protected destroy(): void {\n        super.destroy();\n        this.purgeCache(0);\n    }\n\n}\n\ninterface CacheItem {\n    rowNode: RowNode;\n    lastAccessedTime: number;\n    center?: ICellRendererComp;\n    left?: ICellRendererComp;\n    right?: ICellRendererComp;\n}\n"]}