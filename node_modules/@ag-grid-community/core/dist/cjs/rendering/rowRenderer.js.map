{"version":3,"sources":["../../src/ts/rendering/rowRenderer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,4DAA2D;AAC3D,qDAAoD;AACpD,6CAA4C;AAE5C,oCAOmB;AACnB,oDAAmD;AACnD,uCAAsC;AACtC,8CAAyF;AASzF,gDAA+C;AAW/C,4CAAmD;AACnD,0CAAsE;AACtE,0CAAuD;AACvD,wCAAsC;AACtC,8CAA4D;AAC5D,gDAA+C;AAS/C;IAAiC,+BAAQ;IAAzC;QAAA,qEAunDC;QAlmDW,oCAA8B,GAAmB,EAAE,CAAC;QAK5D,+DAA+D;QAC/D,0CAA0C;QAClC,uBAAiB,GAAW,EAAE,CAAC;QAC/B,mBAAa,GAAW,EAAE,CAAC;QAC3B,gBAAU,GAAoB,EAAE,CAAC;QAEjC,gBAAU,GAAoB,EAAE,CAAC;QACjC,mBAAa,GAAoB,EAAE,CAAC;QAK5C,oFAAoF;QACpF,qFAAqF;QACrF,gFAAgF;QAChF,kEAAkE;QAC1D,uBAAiB,GAAG,KAAK,CAAC;;IA6kDtC,CAAC;IAtkDU,4BAAM,GAAb,UAA0C,aAA4B;QAClE,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;IACtD,CAAC;IAGO,mCAAa,GAArB;QADA,iBAMC;QAJG,IAAI,CAAC,kBAAkB,CAAC,SAAS,CAAC;YAC9B,KAAI,CAAC,WAAW,GAAG,KAAI,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,CAAC;YACnE,KAAI,CAAC,UAAU,EAAE,CAAC;QACtB,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,gCAAU,GAAlB;QACI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,wBAAwB,EAAE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAC1G,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,6BAA6B,EAAE,IAAI,CAAC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACzH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,+BAA+B,EAAE,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAC9H,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,iBAAiB,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACxG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAChH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,EAAE,uCAAkB,CAAC,eAAe,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACzH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,wBAAwB,EAAE,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAEhH,IAAI,CAAC,0BAA0B,EAAE,CAAC;QAElC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,KAAK,qBAAS,CAAC,gBAAgB,CAAC;QACzF,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC;QAE7F,IAAI,CAAC,sBAAsB,EAAE,CAAC;IAClC,CAAC;IAEM,gCAAU,GAAjB;QACI,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAEO,sCAAgB,GAAxB;QACI,IAAI,CAAC,UAAU,kBAAO,6BAAoB,CAAC,IAAI,CAAC,iBAAiB,CAAC,EAAK,6BAAoB,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;IACrH,CAAC;IAED,8GAA8G;IAC9G,6GAA6G;IAC7G,oBAAoB;IACZ,gDAA0B,GAAlC;QAAA,iBAqDC;QApDG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,kBAAkB,EAAE,UAAC,KAAuB;YAC1F,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,aAAa,CAAC,KAAK,CAAC,EAA7B,CAA6B,CAAC,CAAC;YAChE,KAAI,CAAC,cAAc,CAAC,UAAC,GAAW,EAAE,OAAsB;gBACpD,IAAI,OAAO,CAAC,WAAW,EAAE,EAAE;oBACvB,OAAO,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC;iBACxC;YACL,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,iBAAiB,EAAE,UAAA,KAAK;YACtE,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,YAAY,CAAC,KAAK,CAAC,EAA5B,CAA4B,CAAC,CAAC;QACnE,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,0BAA0B,EAAE;YAC1E,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,aAAa,EAAE,EAAxB,CAAwB,CAAC,CAAC;QAC/D,CAAC,CAAC,CAAC;QAEH,6GAA6G;QAC7G,yGAAyG;QACzG,6GAA6G;QAC7G,yGAAyG;QACzG,6CAA6C;QAC7C,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,qCAAqC,EAAE;YACrF,IAAI,KAAI,CAAC,WAAW,EAAE;gBAClB,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,aAAa,EAAE,EAAxB,CAAwB,CAAC,CAAC;aAC9D;QACL,CAAC,CAAC,CAAC;QAEH,IAAM,qBAAqB,GAAG,IAAI,CAAC,kBAAkB,CAAC,sBAAsB,EAAE,CAAC;QAC/E,IAAI,qBAAqB,EAAE;YAEvB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,6BAA6B,EAAE;gBAC7E,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,uBAAuB,EAAE,EAAlC,CAAkC,CAAC,CAAC;YACzE,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,kBAAkB,EAAE;gBAClE,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,8BAA8B,EAAE,EAAzC,CAAyC,CAAC,CAAC;YAChF,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,mBAAmB,EAAE;gBACnE,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,8BAA8B,EAAE,EAAzC,CAAyC,CAAC,CAAC;YAChF,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,oBAAoB,EAAE;gBACpE,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,8BAA8B,EAAE,EAAzC,CAAyC,CAAC,CAAC;YAChF,CAAC,CAAC,CAAC;SAEN;QAED,oCAAoC;QACpC,IAAI,CAAC,qCAAqC,EAAE,CAAC;QAC7C,+DAA+D;QAC/D,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,eAAM,CAAC,0BAA0B,EAAE,IAAI,CAAC,qCAAqC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAErI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACnE,CAAC;IAED,oFAAoF;IAC5E,+CAAyB,GAAjC;QACI,IAAI,CAAC,8BAA8B,CAAC,OAAO,CAAC,UAAA,IAAI,IAAI,OAAA,IAAI,EAAE,EAAN,CAAM,CAAC,CAAC;QAC5D,IAAI,CAAC,8BAA8B,CAAC,MAAM,GAAG,CAAC,CAAC;IACnD,CAAC;IAED,iHAAiH;IACjH,iHAAiH;IACjH,8GAA8G;IAC9G,gBAAgB;IACR,2DAAqC,GAA7C;QAAA,iBA0CC;QAzCG,IAAI,CAAC,yBAAyB,EAAE,CAAC;QAEjC,IAAM,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC,iBAAiB,EAAE,CAAC;QAEvD,IAAI,CAAC,IAAI,EAAE;YAAE,OAAO;SAAE;QAEtB,IAAI,CAAC,OAAO,CAAC,UAAA,GAAG;YACZ,IAAM,sBAAsB,GAAG,UAAC,QAAsC;gBAClE,KAAI,CAAC,eAAe,CAAC,UAAA,QAAQ;oBACzB,IAAI,QAAQ,CAAC,SAAS,EAAE,KAAK,GAAG,EAAE;wBAC9B,QAAQ,CAAC,QAAQ,CAAC,CAAC;qBACtB;gBACL,CAAC,CAAC,CAAC;YACP,CAAC,CAAC;YAEF,IAAM,mBAAmB,GAAG;gBACxB,sBAAsB,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,aAAa,EAAE,EAAxB,CAAwB,CAAC,CAAC;YACjE,CAAC,CAAC;YACF,IAAM,oBAAoB,GAAG;gBACzB,sBAAsB,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,cAAc,EAAE,EAAzB,CAAyB,CAAC,CAAC;YAClE,CAAC,CAAC;YACF,IAAM,+BAA+B,GAAG;gBACpC,sBAAsB,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,yBAAyB,EAAE,EAApC,CAAoC,CAAC,CAAC;YAC7E,CAAC,CAAC;YACF,IAAM,6BAA6B,GAAG;gBAClC,sBAAsB,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,uBAAuB,EAAE,EAAlC,CAAkC,CAAC,CAAC;YAC3E,CAAC,CAAC;YAEF,GAAG,CAAC,gBAAgB,CAAC,eAAM,CAAC,kBAAkB,EAAE,mBAAmB,CAAC,CAAC;YACrE,GAAG,CAAC,gBAAgB,CAAC,eAAM,CAAC,mBAAmB,EAAE,oBAAoB,CAAC,CAAC;YACvE,GAAG,CAAC,gBAAgB,CAAC,eAAM,CAAC,gCAAgC,EAAE,+BAA+B,CAAC,CAAC;YAC/F,GAAG,CAAC,gBAAgB,CAAC,eAAM,CAAC,8BAA8B,EAAE,6BAA6B,CAAC,CAAC;YAE3F,KAAI,CAAC,8BAA8B,CAAC,IAAI,CAAC;gBACrC,GAAG,CAAC,mBAAmB,CAAC,eAAM,CAAC,kBAAkB,EAAE,mBAAmB,CAAC,CAAC;gBACxE,GAAG,CAAC,mBAAmB,CAAC,eAAM,CAAC,mBAAmB,EAAE,oBAAoB,CAAC,CAAC;gBAC1E,GAAG,CAAC,mBAAmB,CAAC,eAAM,CAAC,gCAAgC,EAAE,+BAA+B,CAAC,CAAC;gBAClG,GAAG,CAAC,mBAAmB,CAAC,eAAM,CAAC,8BAA8B,EAAE,6BAA6B,CAAC,CAAC;YAClG,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IAEP,CAAC;IAEO,wCAAkB,GAA1B;QACI,IAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,KAAK,qBAAS,CAAC,gBAAgB,CAAC;QAC1F,IAAM,kBAAkB,GAAG,WAAW,IAAI,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC;QAEzF,uGAAuG;QACvG,yDAAyD;QACzD,IAAM,WAAW,GAAG,kBAAkB,KAAK,IAAI,CAAC,kBAAkB,IAAI,IAAI,CAAC,WAAW,KAAK,WAAW,CAAC;QAEvG,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAE7C,IAAI,WAAW,EAAE;YACb,IAAI,CAAC,sBAAsB,EAAE,CAAC;SACjC;IACL,CAAC;IAED,wGAAwG;IACxG,0FAA0F;IACnF,uCAAiB,GAAxB;QACI,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAC1B,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC,CAAC;QAC1B,IAAM,kBAAkB,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC/D,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,CAAC;IAC5C,CAAC;IAEO,kCAAY,GAApB,UAAqB,KAAwB;QACzC,IAAM,MAAM,GAAsB;YAC9B,WAAW,EAAE,KAAK,CAAC,gBAAgB;YACnC,OAAO,EAAE,KAAK,CAAC,OAAO;YACtB,OAAO,EAAE,KAAK,CAAC,OAAO;YACtB,OAAO,EAAE,KAAK,CAAC,OAAO;YACtB,8DAA8D;YAC9D,oEAAoE;YACpE,2EAA2E;YAC3E,qFAAqF;YACrF,QAAQ,EAAE,IAAI;SACjB,CAAC;QACF,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;IACxC,CAAC;IAEM,0CAAoB,GAA3B,UAA4B,MAAc;QACtC,IAAM,MAAM,GAAkB,EAAE,CAAC;QAEjC,SAAS,QAAQ,CAAC,GAAQ,EAAE,OAAsB;YAC9C,IAAM,KAAK,GAAG,OAAO,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;YAC5C,IAAI,KAAK,EAAE;gBAAE,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAAE;QACtC,CAAC;QAED,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;QAChD,sBAAa,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC;QAC5C,sBAAa,CAAC,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QAEzC,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,6CAAuB,GAA9B;QACI,IAAI,CAAC,mBAAmB,CACpB,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAC5C,CAAC;QAEF,IAAI,CAAC,mBAAmB,CACpB,IAAI,CAAC,aAAa,EAClB,IAAI,CAAC,cAAc,CAAC,sBAAsB,EAAE,CAC/C,CAAC;IACN,CAAC;IAEM,mCAAa,GAApB;QACI,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAEM,sCAAgB,GAAvB;QACI,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B,CAAC;IAEO,yCAAmB,GAA3B,UAA4B,QAAyB,EAAE,QAAmB;QAA1E,iBAsBC;QArBG,QAAQ,CAAC,OAAO,CAAC,UAAC,GAAkB;YAChC,GAAG,CAAC,gBAAgB,EAAE,CAAC;YACvB,GAAG,CAAC,iBAAiB,EAAE,CAAC;QAC5B,CAAC,CAAC,CAAC;QAEH,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;QAEpB,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO;SAAE;QAE1B,QAAQ,CAAC,OAAO,CAAC,UAAA,OAAO;YACpB,IAAM,MAAM,GAAG,IAAI,6BAAa,CAC5B,KAAI,CAAC,MAAM,EACX,OAAO,EACP,KAAI,CAAC,KAAK,EACV,KAAK,EACL,KAAK,EACL,KAAI,CAAC,WAAW,CACnB,CAAC;YAEF,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAC1B,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,4CAAsB,GAA9B;QACI,kEAAkE;QAClE,IAAM,MAAM,GAAsB;YAC9B,WAAW,EAAE,IAAI;SACpB,CAAC;QAEF,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,CAAC;IACxC,CAAC;IAED,0DAA0D;IAClD,mDAA6B,GAArC,UAAsC,QAAmB;QACrD,IAAM,MAAM,GAAa,EAAE,CAAC;QAE5B,IAAI,iBAAO,CAAC,QAAQ,CAAC,EAAE;YAAE,OAAO,MAAM,CAAC;SAAE;QAEzC,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,UAAC,KAAa,EAAE,WAA0B;YAC5E,IAAM,OAAO,GAAG,WAAW,CAAC,UAAU,EAAE,CAAC;YACzC,IAAI,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBAChC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACtB;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,MAAM,CAAC;IAClB,CAAC;IAEM,gCAAU,GAAjB,UAAkB,QAAoB;QAClC,oDAAoD;QACpD,IAAM,cAAc,GAAG,QAAQ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC;QAE/D,IAAI,cAAc,EAAE;YAChB,IAAM,eAAe,GAAG,IAAI,CAAC,6BAA6B,CAAC,QAAS,CAAC,CAAC;YACtE,kBAAkB;YAClB,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;SACxC;QAED,sBAAsB;QACtB,IAAI,CAAC,sBAAsB,CAAC;YACxB,WAAW,EAAE,cAAc;SAC9B,CAAC,CAAC;IACP,CAAC;IAEO,yDAAmC,GAA3C,UAA4C,MAAyB;QACjE,IAAM,WAAW,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,6BAA6B,EAAE,CAAC;QAE3G,IAAI,iBAAO,CAAC,WAAW,CAAC,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE1C,+FAA+F;QAC/F,+FAA+F;QAC/F,iGAAiG;QACjG,mGAAmG;QACnG,sGAAsG;QACtG,8DAA8D;QAC9D,IAAM,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC;QAC7C,IAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,aAAa,EAAE,mBAAQ,CAAC,sBAAsB,CAAC,CAAC;QACnG,IAAM,oBAAoB,GAAG,iBAAO,CAAC,OAAO,CAAC,CAAC;QAE9C,OAAO,oBAAoB,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,WAAW,CAAC;IACrD,CAAC;IAED,oBAAoB;IACpB,wDAAwD;IACxD,uCAAuC;IACvC,oFAAoF;IACpF,gDAAgD;IAChD,0DAA0D;IAClD,4CAAsB,GAA9B,UAA+B,MAA8B;QAA9B,uBAAA,EAAA,WAA8B;QACzD,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAExB,IAAM,WAAW,GAAwB,IAAI,CAAC,mCAAmC,CAAC,MAAM,CAAC,CAAC;QAE1F,IAAI,CAAC,sBAAsB,EAAE,CAAC;QAC9B,IAAI,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;QAElC,0GAA0G;QAC1G,mFAAmF;QACnF,IAAM,WAAW,GAAG,CAAC,IAAI,CAAC,WAAW,IAAI,CAAC,CAAC,MAAM,CAAC,WAAW,CAAC;QAC9D,IAAM,OAAO,GAAG,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC;QAE1E,kFAAkF;QAClF,yEAAyE;QACzE,IAAM,aAAa,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;QAC9D,IAAI,CAAC,WAAW,EAAE;YACd,IAAI,CAAC,iBAAiB,EAAE,CAAC;SAC5B;QAED,IAAM,4BAA4B,GAAG;YACjC,IAAI,WAAW,IAAI,IAAI,IAAI,aAAa,IAAI,IAAI,EAAE;gBAAE,OAAO,KAAK,CAAC;aAAE;YACnE,IAAI,GAAG,GAAG,KAAK,CAAC;YAEhB,sBAAa,CAAC,aAAa,EAAE,UAAC,GAAW,EAAE,OAAsB;gBAC7D,IAAM,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;gBACrC,IAAM,aAAa,GAAG,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAC,QAAQ,CAAC;gBAC/D,IAAM,WAAW,GAAG,OAAO,CAAC,SAAS,IAAI,WAAW,CAAC,SAAS,CAAC;gBAC/D,IAAI,aAAa,IAAI,WAAW,EAAE;oBAC9B,GAAG,GAAG,IAAI,CAAC;iBACd;YACL,CAAC,CAAC,CAAC;YAEH,OAAO,GAAG,CAAC;QACf,CAAC,CAAC;QAEF,IAAM,mBAAmB,GAAG,4BAA4B,EAAE,CAAC;QAE3D,IAAI,CAAC,MAAM,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;QAEpC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;YAClB,IAAI,CAAC,uBAAuB,EAAE,CAAC;SAClC;QAED,IAAI,CAAC,4BAA4B,EAAE,CAAC;QAEpC,mGAAmG;QACnG,yGAAyG;QACzG,IAAI,CAAC,mBAAmB,EAAE;YACtB,IAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,CAAC;SACxC;QAED,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAChC,CAAC;IAEO,0CAAoB,GAA5B,UAA6B,MAAyB;QAClD,IAAM,WAAW,GAAG,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,CAAC;QACrD,IAAM,mBAAmB,GAAG,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,CAAC;QAEhF,IAAI,WAAW,IAAI,CAAC,mBAAmB,EAAE;YACrC,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,WAAW,EAAE,CAAC;SACrD;IACL,CAAC;IAEO,4CAAsB,GAA9B;QACI,4EAA4E;QAC5E,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,IAAI,CAAC,yBAAyB,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YACpD,OAAO;SACV;QAED,IAAI,eAAe,GAAG,IAAI,CAAC,eAAe,CAAC,oBAAoB,EAAE,CAAC;QAClE,wFAAwF;QACxF,+FAA+F;QAC/F,wDAAwD;QACxD,8FAA8F;QAC9F,kCAAkC;QAClC,IAAI,eAAe,KAAK,CAAC,EAAE;YACvB,eAAe,GAAG,CAAC,CAAC;SACvB;QAED,IAAI,CAAC,yBAAyB,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;IACnE,CAAC;IAEO,sCAAgB,GAAxB;QACI,IAAI,IAAI,CAAC,iBAAiB,EAAE;YACxB,MAAM,IAAI,KAAK,CACX,kFAAkF;gBAClF,kGAAkG;gBAClG,4EAA4E;gBAC5E,uFAAuF;gBACvF,gDAAgD,CACnD,CAAC;SACL;QAED,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC;IAClC,CAAC;IAEO,0CAAoB,GAA5B;QACI,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC;IACnC,CAAC;IAED,4GAA4G;IAC5G,4GAA4G;IAC5G,2GAA2G;IAC3G,gBAAgB;IACR,wCAAkB,GAA1B,UAA2B,YAAiC;QACxD,IAAI,YAAY,EAAE;YACd,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;SACjH;IACL,CAAC;IAEM,iCAAW,GAAlB,UAAmB,MAAuB;QAAvB,uBAAA,EAAA,cAAuB;QACtC,IAAI,CAAC,cAAc,CAAC,UAAC,GAAW,EAAE,OAAsB;YACpD,OAAO,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;IACP,CAAC;IAEO,wCAAkB,GAA1B;QACI,wFAAwF;QACxF,kFAAkF;QAClF,uCAAuC;QACvC,IAAI,CAAC,eAAe,CAAC,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,kBAAkB,EAAE,EAA7B,CAA6B,CAAC,CAAC;IACpE,CAAC;IAEM,qCAAe,GAAtB,UAAuB,QAAsC;QACzD,IAAI,CAAC,cAAc,CAAC,UAAC,GAAW,EAAE,OAAsB,IAAK,OAAA,OAAO,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAjC,CAAiC,CAAC,CAAC;IACpG,CAAC;IAEO,oCAAc,GAAtB,UAAuB,QAAuD;QAC1E,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;QAChD,sBAAa,CAAC,IAAI,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;QACzC,sBAAa,CAAC,IAAI,CAAC,aAAa,EAAE,QAAQ,CAAC,CAAC;IAChD,CAAC;IAEM,4CAAsB,GAA7B,UAA8B,SAAiB,EAAE,QAAgB,EAAE,QAAkB;QACjF,IAAM,OAAO,GAAG,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACjD,IAAI,OAAO,EAAE;YACT,OAAO,CAAC,gBAAgB,CAAC,SAAS,EAAE,QAAQ,CAAC,CAAC;SACjD;IACL,CAAC;IAEM,gCAAU,GAAjB,UAAkB,MAA6B;QAA7B,uBAAA,EAAA,WAA6B;QACnC,IAAA,8BAAU,EAAE,4BAAS,CAAY;QACzC,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,OAAO,EAAE,UAAA,QAAQ,IAAI,OAAA,QAAQ,CAAC,SAAS,CAAC,EAAE,UAAU,YAAA,EAAE,SAAS,WAAA,EAAE,CAAC,EAA7C,CAA6C,CAAC,CAAC;IAC7H,CAAC;IAEM,kCAAY,GAAnB,UAAoB,MAA+B;QAA/B,uBAAA,EAAA,WAA+B;QAC/C,IAAM,iBAAiB,GAAG;YACtB,YAAY,EAAE,MAAM,CAAC,KAAK;YAC1B,OAAO,EAAE,KAAK;YACd,aAAa,EAAE,MAAM,CAAC,aAAa;SACtC,CAAC;QACF,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,OAAO,EAAE,UAAA,QAAQ;YAClE,IAAI,QAAQ,CAAC,oBAAoB,EAAE,EAAE;gBACjC,IAAM,OAAO,GAAG,QAAQ,CAAC,cAAc,EAAE,CAAC;gBAC1C,IAAI,OAAO,EAAE;oBACT,OAAO,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;iBACjC;aACJ;iBAAM;gBACH,QAAQ,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;aAC3C;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAEM,8CAAwB,GAA/B,UAAgC,MAAsC;QAElE,IAAM,GAAG,GAAwB,EAAE,CAAC;QAEpC,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,OAAO,EAAE,UAAA,QAAQ;YAClE,IAAM,YAAY,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;YAEhD,IAAI,YAAY,EAAE;gBACd,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;aAC1B;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,4CAAsB,GAA7B,UAA8B,MAAsC;QAEhE,IAAM,GAAG,GAAsB,EAAE,CAAC;QAElC,IAAI,CAAC,uBAAuB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,OAAO,EAAE,UAAA,QAAQ;YAClE,IAAM,UAAU,GAAG,QAAQ,CAAC,aAAa,EAAE,CAAC;YAE5C,IAAI,UAAU,EAAE;gBACZ,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;aACxB;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,qCAAe,GAAtB;QACI,IAAM,GAAG,GAAmB,EAAE,CAAC;QAE/B,IAAI,CAAC,eAAe,CAAC,UAAA,QAAQ;YACzB,IAAI,QAAQ,CAAC,SAAS,EAAE,EAAE;gBACtB,IAAM,YAAY,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;gBAChD,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;aAC1B;QACL,CAAC,CAAC,CAAC;QAEH,OAAO,GAAG,CAAC;IACf,CAAC;IAED,wGAAwG;IACxG,0GAA0G;IAClG,6CAAuB,GAA/B,UAAgC,QAA2B,EAAE,OAA6B,EAAE,QAAuC;QAAnI,iBA4EC;QA3EG,IAAI,SAAc,CAAC;QAEnB,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;YAClB,SAAS,GAAG;gBACR,GAAG,EAAE,EAAE;gBACP,MAAM,EAAE,EAAE;gBACV,MAAM,EAAE,EAAE;aACb,CAAC;YAEF,QAAQ,CAAC,OAAO,CAAC,UAAA,OAAO;gBACpB,IAAM,EAAE,GAAG,OAAO,CAAC,EAAG,CAAC;gBACvB,IAAI,OAAO,CAAC,SAAS,KAAK,qBAAS,CAAC,UAAU,EAAE;oBAC5C,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;iBAC5B;qBAAM,IAAI,OAAO,CAAC,SAAS,KAAK,qBAAS,CAAC,aAAa,EAAE;oBACtD,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;iBAC/B;qBAAM;oBACH,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC;iBAC/B;YACL,CAAC,CAAC,CAAC;SACN;QAED,IAAI,SAAc,CAAC;QAEnB,IAAI,gBAAM,CAAC,OAAO,CAAC,EAAE;YACjB,SAAS,GAAG,EAAE,CAAC;YACf,OAAO,CAAC,OAAO,CAAC,UAAC,MAAuB;gBACpC,IAAM,MAAM,GAAkB,KAAI,CAAC,gBAAgB,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;gBAC1E,IAAI,gBAAM,CAAC,MAAM,CAAC,EAAE;oBAChB,SAAS,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,GAAG,IAAI,CAAC;iBACpC;YACL,CAAC,CAAC,CAAC;SACN;QAED,IAAM,UAAU,GAAG,UAAC,OAAsB;YACtC,IAAM,OAAO,GAAY,OAAO,CAAC,UAAU,EAAE,CAAC;YAC9C,IAAM,EAAE,GAAG,OAAO,CAAC,EAAG,CAAC;YACvB,IAAM,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC;YAEnC,wDAAwD;YACxD,IAAI,gBAAM,CAAC,SAAS,CAAC,EAAE;gBACnB,IAAI,QAAQ,KAAK,qBAAS,CAAC,aAAa,EAAE;oBACtC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;wBACvB,OAAO;qBACV;iBACJ;qBAAM,IAAI,QAAQ,KAAK,qBAAS,CAAC,UAAU,EAAE;oBAC1C,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;wBACpB,OAAO;qBACV;iBACJ;qBAAM;oBACH,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;wBACvB,OAAO;qBACV;iBACJ;aACJ;YAED,OAAO,CAAC,eAAe,CAAC,UAAA,QAAQ;gBAC5B,IAAM,KAAK,GAAW,QAAQ,CAAC,SAAS,EAAE,CAAC,KAAK,EAAE,CAAC;gBACnD,IAAM,qBAAqB,GAAG,SAAS,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;gBAE7D,IAAI,qBAAqB,EAAE;oBAAE,OAAO;iBAAE;gBACtC,IAAI,QAAQ,EAAE;oBAAE,QAAQ,CAAC,QAAQ,CAAC,CAAC;iBAAE;YACzC,CAAC,CAAC,CAAC;QACP,CAAC,CAAC;QAEF,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,UAAC,KAAa,EAAE,OAAsB;YACxE,UAAU,CAAC,OAAO,CAAC,CAAC;QACxB,CAAC,CAAC,CAAC;QAEH,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;SACvC;QAED,IAAI,IAAI,CAAC,aAAa,EAAE;YACpB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;SAC1C;IACL,CAAC;IAES,6BAAO,GAAjB;QACI,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACzB,iBAAM,OAAO,WAAE,CAAC;IACpB,CAAC;IAEO,uCAAiB,GAAzB;QACI,IAAM,kBAAkB,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC/D,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,CAAC;IAC5C,CAAC;IAEO,iCAAW,GAAnB;QACI,gEAAgE;QAChE,IAAM,eAAe,GAAa,EAAE,CAAC;QACrC,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,UAAC,KAAa,EAAE,OAAsB;YACxE,IAAM,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC,EAAE,IAAI,IAAI,CAAC;YACjD,IAAI,QAAQ,EAAE;gBACV,eAAe,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aAC/B;QACL,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,CAAC;QAErC,6FAA6F;QAC7F,IAAM,YAAY,GAAW,EAAE,CAAC;QAChC,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,UAAC,KAAa,EAAE,OAAsB;YACxE,IAAM,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;YACrC,YAAY,CAAC,OAAO,CAAC,EAAG,CAAC,GAAG,OAAO,CAAC;QACxC,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,iBAAiB,GAAG,EAAE,CAAC;QAE5B,OAAO,YAAY,CAAC;IACxB,CAAC;IAED,6BAA6B;IACrB,oCAAc,GAAtB,UAAuB,YAAmB;QAA1C,iBAWC;QAVG,gEAAgE;QAChE,0BAA0B;QAC1B,YAAY,CAAC,OAAO,CAAC,UAAA,aAAa;YAC9B,IAAM,OAAO,GAAG,KAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC;YACtD,IAAI,OAAO,EAAE;gBACT,OAAO,CAAC,gBAAgB,EAAE,CAAC;gBAC3B,OAAO,CAAC,iBAAiB,EAAE,CAAC;aAC/B;YACD,OAAO,KAAI,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC;QACjD,CAAC,CAAC,CAAC;IACP,CAAC;IAED,mEAAmE;IACnE,0EAA0E;IAC1E,mCAAmC;IACnC,8CAA8C;IACvC,uCAAiB,GAAxB;QACI,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;QAC/B,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,IAAI,CAAC,4BAA4B,EAAE,CAAC;IACxC,CAAC;IAEO,6CAAuB,GAA/B,UAAgC,aAAuB;QACnD,mCAAmC;QACnC,IAAM,gBAAgB,GAAkC,EAAE,CAAC;QAC3D,aAAa,CAAC,OAAO,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,gBAAgB,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,EAAhC,CAAgC,CAAC,CAAC;QAEjE,IAAM,eAAe,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC5D,IAAM,gBAAgB,GAAa,eAAe,CAAC,MAAM,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAxB,CAAwB,CAAC,CAAC;QAE7F,IAAI,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;IAC1C,CAAC;IAEO,4CAAsB,GAA9B,UAA+B,aAAwD;QAAvF,iBAuBC;QAtBG,qCAAqC;QACrC,IAAM,aAAa,GAAG,6BAAoB,CAAC,IAAI,CAAC,gBAAgB,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAExF,IAAM,cAAc,GAAG,UAAC,QAAgB,EAAE,OAAsB;YAC5D,IAAM,KAAK,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC;YAC5C,IAAI,KAAK,IAAI,IAAI,EAAE;gBAAE,OAAO;aAAE;YAC9B,IAAI,KAAK,GAAG,KAAI,CAAC,gBAAgB,IAAI,KAAK,GAAG,KAAI,CAAC,eAAe,EAAE;gBAC/D,IAAI,KAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,EAAE;oBACpC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;iBAC7B;aACJ;QACL,CAAC,CAAC;QAEF,yFAAyF;QACzF,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,cAAc,CAAC,CAAC;QAEtD,8EAA8E;QAC9E,sBAAa,CAAC,aAAa,EAAE,cAAc,CAAC,CAAC;QAE7C,aAAa,CAAC,IAAI,CAAC,UAAC,CAAS,EAAE,CAAS,IAAK,OAAA,CAAC,GAAG,CAAC,EAAL,CAAK,CAAC,CAAC;QAEpD,OAAO,aAAa,CAAC;IACzB,CAAC;IAEO,4BAAM,GAAd,UAAe,aAAwD,EAAE,OAAe,EAAE,WAAmB;QAA7G,iBA+CC;QA/CwE,wBAAA,EAAA,eAAe;QAAE,4BAAA,EAAA,mBAAmB;QACzG,IAAI,CAAC,yBAAyB,CAAC,YAAY,EAAE,CAAC;QAC9C,IAAI,CAAC,+BAA+B,EAAE,CAAC;QAEvC,qDAAqD;QACrD,qFAAqF;QACrF,wEAAwE;QACxE,qGAAqG;QAErG,sFAAsF;QACtF,yFAAyF;QACzF,IAAM,aAAa,GAAG,IAAI,CAAC,sBAAsB,CAAC,aAAa,CAAC,CAAC;QAEjE,IAAI,CAAC,uBAAuB,CAAC,aAAa,CAAC,CAAC;QAE5C,0GAA0G;QAC1G,8FAA8F;QAC9F,IAAI,IAAI,CAAC,WAAW,EAAE;YAClB,OAAO,GAAG,KAAK,CAAC;SACnB;QAED,kBAAkB;QAClB,IAAM,QAAQ,GAAoB,EAAE,CAAC;QAErC,aAAa,CAAC,OAAO,CAAC,UAAA,QAAQ;YAC1B,IAAM,OAAO,GAAG,KAAI,CAAC,oBAAoB,CAAC,QAAQ,EAAE,aAAa,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;YACzF,IAAI,gBAAM,CAAC,OAAO,CAAC,EAAE;gBACjB,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aAC1B;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,aAAa,EAAE;YACf,IAAM,iBAAiB,GAAG,WAAW,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,wBAAwB,EAAE,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;YAClH,IAAI,iBAAiB,EAAE;gBACnB,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,cAAc,CAAC;oBAChC,KAAI,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;oBAC5C,KAAI,CAAC,gBAAgB,EAAE,CAAC;oBACxB,KAAI,CAAC,4BAA4B,EAAE,CAAC;gBACxC,CAAC,CAAC,CAAC;aACN;iBAAM;gBACH,IAAI,CAAC,cAAc,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;aAC/C;SACJ;QAED,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,CAAC;IACtC,CAAC;IAEO,kDAA4B,GAApC;QACI,IAAM,KAAK,GAA8B,EAAC,IAAI,EAAE,eAAM,CAAC,4BAA4B,EAAC,CAAC;QACrF,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;IAC3C,CAAC;IAEO,+CAAyB,GAAjC;QACI,IAAM,WAAW,GAAG,IAAI,CAAC,gBAAgB,CAAC,aAAa,EAAE,CAAC;QAC1D,IAAM,YAAY,GAAG,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,CAAC;QAC5D,IAAM,iBAAiB,GAAG,IAAI,CAAC,WAAW,KAAK,WAAW,IAAI,YAAY,KAAK,IAAI,CAAC,YAAY,CAAC;QAEjG,IAAI,iBAAiB,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;YAC/B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;YAEjC,IAAI,IAAI,CAAC,kBAAkB,EAAE;gBACzB,IAAI,CAAC,2BAA2B,EAAE,CAAC;aACtC;SACJ;IACL,CAAC;IAED,uHAAuH;IACvH,kGAAkG;IAC1F,iDAA2B,GAAnC;QACI,iGAAiG;QACjG,oFAAoF;QACpF,IAAM,YAAY,GAAa,EAAE,CAAC;QAElC,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,UAAC,EAAU,EAAE,OAAsB;YACrE,IAAI,OAAO,CAAC,WAAW,EAAE,EAAE;gBACvB,IAAM,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC;gBAE/C,YAAY,CAAC,IAAI,CAAC,QAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;aAC3C;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,uBAAuB,EAAE,CAAC;QAC/B,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;QAClC,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC7B,CAAC;IAEM,0CAAoB,GAA3B,UAA4B,iBAA6B;QACrD,IAAM,YAAY,GAAa,EAAE,CAAC;QAElC,IAAM,qBAAqB,GAAG,CAAC,CAAC,iBAAiB,CAAC;QAClD,IAAM,YAAY,GAA2C,qBAAqB,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;QAEpG,IAAI,qBAAqB,IAAI,YAAY,EAAE;YACvC,iBAAkB,CAAC,OAAO,CAAC,UAAA,CAAC,IAAI,OAAA,YAAY,CAAC,CAAC,CAAC,EAAG,CAAC,GAAG,IAAI,EAA1B,CAA0B,CAAC,CAAC;SAC/D;QAED,sBAAa,CAAC,IAAI,CAAC,iBAAiB,EAAE,UAAC,EAAU,EAAE,OAAsB;YACrE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;gBAAE,OAAO;aAAE;YAEvC,IAAM,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;YAErC,IAAI,qBAAqB,IAAI,YAAY,EAAE;gBACvC,6FAA6F;gBAC7F,+FAA+F;gBAC/F,2FAA2F;gBAC3F,kGAAkG;gBAClG,IAAM,QAAQ,GAAG,CAAC,OAAO,CAAC,KAAK,GAAG,CAAC,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;gBACvF,IAAM,YAAY,GAAG,CAAC,YAAY,CAAC,OAAO,CAAC,EAAG,CAAC,IAAI,CAAC,YAAY,CAAC,QAAS,CAAC,CAAC;gBAC5E,IAAI,YAAY,EAAE;oBAAE,OAAO;iBAAE;aAChC;YAED,IAAM,sBAAsB,GAAG,OAAO,CAAC,gBAAgB,EAAE,CAAC;YAC1D,IAAI,CAAC,sBAAsB,EAAE;gBACzB,IAAM,QAAQ,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC,QAAQ,CAAC;gBAE/C,YAAY,CAAC,IAAI,CAAC,QAAS,CAAC,QAAQ,EAAE,CAAC,CAAC;aAC3C;QACL,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;QAClC,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC7B,CAAC;IAEO,0CAAoB,GAA5B,UACI,QAAgB,EAChB,aAA0E,EAC1E,OAAgB,EAChB,WAAoB;QAEpB,IAAI,OAAO,GAAmB,IAAI,CAAC;QACnC,IAAI,MAAM,GAAyB,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QAEpE,kEAAkE;QAClE,IAAI,CAAC,MAAM,EAAE;YACT,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAChD,IAAI,gBAAM,CAAC,OAAO,CAAC,IAAI,gBAAM,CAAC,aAAa,CAAC,IAAI,aAAa,CAAC,OAAO,CAAC,EAAG,CAAC,IAAI,OAAO,CAAC,eAAe,EAAE;gBACnG,MAAM,GAAG,aAAa,CAAC,OAAO,CAAC,EAAG,CAAC,CAAC;gBACpC,aAAa,CAAC,OAAO,CAAC,EAAG,CAAC,GAAG,IAAI,CAAC;aACrC;SACJ;QAED,IAAM,iBAAiB,GAAG,CAAC,MAAM,CAAC;QAElC,IAAI,iBAAiB,EAAE;YACnB,mBAAmB;YACnB,IAAI,CAAC,OAAO,EAAE;gBACV,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;aACnD;YAED,IAAI,gBAAM,CAAC,OAAO,CAAC,EAAE;gBACjB,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,EAAE,WAAW,CAAC,CAAC;aAC7D;iBAAM;gBACH,gEAAgE;gBAChE,2CAA2C;gBAC3C,OAAO;aACV;SACJ;QAED,IAAI,OAAO,EAAE;YACT,yGAAyG;YACzG,kGAAkG;YAClG,OAAO,CAAC,eAAe,GAAG,IAAI,CAAC;SAClC;QAED,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,GAAG,MAAO,CAAC;QAE3C,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,oCAAc,GAAtB,UAAuB,UAAgE,EAAE,OAAgB;QAAzG,iBA0BC;QAzBG,IAAM,oBAAoB,GAAmB,EAAE,CAAC;QAChD,sBAAa,CAAC,UAAU,EAAE,UAAC,MAAc,EAAE,MAAqB;YAC5D,kCAAkC;YAClC,IAAI,CAAC,MAAM,EAAE;gBAAE,OAAO;aAAE;YAExB,MAAM,CAAC,gBAAgB,EAAE,CAAC;YAC1B,IAAI,OAAO,EAAE;gBACT,KAAI,CAAC,aAAa,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,GAAG,MAAM,CAAC;gBACpD,oBAAoB,CAAC,IAAI,CAAC;oBACtB,MAAM,CAAC,iBAAiB,EAAE,CAAC;oBAC3B,OAAO,KAAI,CAAC,aAAa,CAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC;gBACtD,CAAC,CAAC,CAAC;aACN;iBAAM;gBACH,MAAM,CAAC,iBAAiB,EAAE,CAAC;aAC9B;QACL,CAAC,CAAC,CAAC;QACH,IAAI,OAAO,EAAE;YACT,qFAAqF;YACrF,mDAAmD;YACnD,oBAAoB,CAAC,IAAI,CAAC;gBACtB,KAAI,CAAC,gBAAgB,EAAE,CAAC;gBACxB,KAAI,CAAC,4BAA4B,EAAE,CAAC;YACxC,CAAC,CAAC,CAAC;YACH,0BAAe,CAAC,oBAAoB,CAAC,CAAC;SACzC;IACL,CAAC;IAEO,yCAAmB,GAA3B;QAAA,iBAQC;QAPG,mEAAmE;QACnE,IAAI,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,EAAE;YAChD,4DAA4D;YAC5D,MAAM,CAAC,UAAU,CAAC;gBACd,KAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;YACzB,CAAC,EAAE,CAAC,CAAC,CAAC;SACT;IACL,CAAC;IAEO,qDAA+B,GAAvC;QAAA,iBAoGC;QAnGG,IAAI,QAAgB,CAAC;QACrB,IAAI,OAAe,CAAC;QAEpB,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,EAAE;YACxC,QAAQ,GAAG,CAAC,CAAC;YACb,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC,uCAAuC;SACxD;aAAM,IAAI,IAAI,CAAC,WAAW,EAAE;YACzB,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;YAClD,OAAO,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;SACnD;aAAM;YACH,IAAM,YAAY,GAAG,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC;YACpE,IAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,qBAAqB,EAAE,CAAC;YAEpE,IAAI,iBAAiB,GAAG,KAAK,CAAC;YAC9B,IAAI,UAAU,SAAQ,CAAC;YACvB,IAAI,SAAS,SAAQ,CAAC;YACtB,GAAG;gBACC,IAAM,gBAAgB,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;gBACzD,IAAA,oDAAiF,EAAhF,kCAAc,EAAE,gCAAgE,CAAC;gBACxF,IAAM,gBAAgB,GAAG,IAAI,CAAC,yBAAyB,CAAC,mBAAmB,EAAE,CAAC;gBAE9E,IAAM,UAAU,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,EAAE,CAAC;gBACvE,IAAM,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC;gBACpC,IAAM,eAAe,GAAG,UAAU,CAAC,MAAM,CAAC;gBAE1C,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,YAAY,GAAG,gBAAgB,GAAG,YAAY,EAAE,cAAc,CAAC,GAAG,gBAAgB,CAAC;gBACzG,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,GAAG,gBAAgB,GAAG,YAAY,EAAE,aAAa,CAAC,GAAG,gBAAgB,CAAC;gBAE1G,wGAAwG;gBACxG,iBAAiB,GAAG,IAAI,CAAC,yCAAyC,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;aAE7F,QAAQ,iBAAiB,EAAE;YAE5B,IAAI,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;YACxE,IAAI,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,kBAAkB,CAAC,SAAS,CAAC,CAAC;YAEtE,IAAM,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;YAC5D,IAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;YAE1D,8CAA8C;YAC9C,IAAI,aAAa,GAAG,YAAY,EAAE;gBAC9B,aAAa,GAAG,YAAY,CAAC;aAChC;YAED,IAAI,YAAY,GAAG,WAAW,EAAE;gBAC5B,YAAY,GAAG,WAAW,CAAC;aAC9B;YAED,QAAQ,GAAG,aAAa,CAAC;YACzB,OAAO,GAAG,YAAY,CAAC;SAC1B;QAED,6FAA6F;QAC7F,4FAA4F;QAC5F,+FAA+F;QAC/F,wDAAwD;QACxD,IAAM,eAAe,GAAG,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,KAAK,qBAAS,CAAC,iBAAiB,CAAC;QAC/F,IAAM,2BAA2B,GAAG,IAAI,CAAC,kBAAkB,CAAC,mCAAmC,EAAE,CAAC;QAClG,IAAM,gBAAgB,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,EAAE,GAAG,CAAC,CAAC;QAE/E,IAAI,eAAe,IAAI,CAAC,2BAA2B,EAAE;YACjD,IAAI,OAAO,GAAG,QAAQ,GAAG,gBAAgB,EAAE;gBACvC,OAAO,GAAG,QAAQ,GAAG,gBAAgB,CAAC;aACzC;SACJ;QAED,IAAM,YAAY,GAAG,QAAQ,KAAK,IAAI,CAAC,gBAAgB,CAAC;QACxD,IAAM,WAAW,GAAG,OAAO,KAAK,IAAI,CAAC,eAAe,CAAC;QAErD,IAAI,YAAY,IAAI,WAAW,EAAE;YAC7B,IAAI,CAAC,gBAAgB,GAAG,QAAQ,CAAC;YACjC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC;YAE/B,IAAM,OAAK,GAAyB;gBAChC,IAAI,EAAE,eAAM,CAAC,sBAAsB;gBACnC,QAAQ,EAAE,QAAQ;gBAClB,OAAO,EAAE,OAAO;gBAChB,GAAG,EAAE,IAAI,CAAC,OAAO;gBACjB,SAAS,EAAE,IAAI,CAAC,SAAS;aAC5B,CAAC;YAEF,IAAI,CAAC,YAAY,CAAC,aAAa,CAAC,OAAK,CAAC,CAAC;SAC1C;QAED,yEAAyE;QACzE,IAAI,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,EAAE;YACvC,IAAM,OAAK,GAA2B;gBAClC,IAAI,EAAE,eAAM,CAAC,yBAAyB;gBACtC,QAAQ,EAAE,QAAQ;gBAClB,OAAO,EAAE,OAAO;gBAChB,GAAG,EAAE,IAAI,CAAC,OAAO;gBACjB,SAAS,EAAE,IAAI,CAAC,SAAS;aAC5B,CAAC;YAEF,uEAAuE;YACvE,mEAAmE;YACnE,wCAAwC;YACxC,MAAM,CAAC,UAAU,CAAC,cAAM,OAAA,KAAI,CAAC,YAAY,CAAC,iBAAiB,CAAC,OAAK,CAAC,EAA1C,CAA0C,EAAE,EAAE,CAAC,CAAC;SAC3E;IACL,CAAC;IAEO,+DAAyC,GAAjD,UAAkD,QAAgB,EAAE,WAAmB;QACnF,8GAA8G;QAC9G,gFAAgF;QAChF,IAAM,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,qBAAqB,CAAC,QAAQ,EAAE,WAAW,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAEtF,IAAI,GAAG,EAAE;YACL,IAAI,CAAC,sBAAsB,EAAE,CAAC;SACjC;QAED,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,gDAA0B,GAAjC;QACI,OAAO,IAAI,CAAC,gBAAgB,CAAC;IACjC,CAAC;IAEM,+CAAyB,GAAhC;QACI,OAAO,IAAI,CAAC,eAAe,CAAC;IAChC,CAAC;IAED,mEAAmE;IACnE,8FAA8F;IAC9F,qGAAqG;IACrG,yDAAyD;IACzD,0FAA0F;IAC1F,8FAA8F;IAC9F,uEAAuE;IACvE,4FAA4F;IAC5F,uFAAuF;IACvF,wFAAwF;IACxF,wDAAwD;IAChD,0CAAoB,GAA5B,UAA6B,OAAsB;QAC/C,IAAM,UAAU,GAAY,KAAK,CAAC;QAClC,IAAM,QAAQ,GAAY,IAAI,CAAC;QAC/B,IAAM,OAAO,GAAG,OAAO,CAAC,UAAU,EAAE,CAAC;QAErC,IAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;QACnE,IAAM,YAAY,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;QACzC,IAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC;QAEnC,IAAM,kBAAkB,GAAG,WAAW,IAAI,YAAY,IAAI,WAAW,CAAC;QAEtE,qCAAqC;QACrC,IAAI,CAAC,kBAAkB,EAAE;YACrB,OAAO,UAAU,CAAC;SACrB;QAED,yFAAyF;QACzF,yFAAyF;QACzF,yCAAyC;QACzC,IAAM,cAAc,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;QAClE,OAAO,cAAc,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,UAAU,CAAC;IAClD,CAAC;IAEO,kCAAY,GAApB,UAAqB,OAAgB,EAAE,OAAgB,EAAE,WAAoB;QACzE,IAAM,sBAAsB,GAAG,IAAI,CAAC,kBAAkB,CAAC,wBAAwB,EAAE,CAAC;QAElF,4FAA4F;QAC5F,uGAAuG;QACvG,+DAA+D;QAE/D,wGAAwG;QACxG,uEAAuE;QACvE,IAAM,0BAA0B,GAAG,WAAW,IAAI,CAAC,sBAAsB,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;QAE/F,IAAM,GAAG,GAAG,IAAI,6BAAa,CACzB,IAAI,CAAC,MAAM,EACX,OAAO,EACP,IAAI,CAAC,KAAK,EACV,OAAO,EACP,0BAA0B,EAC1B,IAAI,CAAC,WAAW,CACnB,CAAC;QAEF,OAAO,GAAG,CAAC;IACf,CAAC;IAEM,sCAAgB,GAAvB;QACI,IAAM,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAE5C,OAAO,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,GAAG,CAAC,UAAA,GAAG,IAAI,OAAA,YAAY,CAAC,GAAG,CAAE,CAAC,UAAU,EAAE,EAA/B,CAA+B,CAAC,CAAC;IACjF,CAAC;IAED,gGAAgG;IAChG,yFAAyF;IAClF,wCAAkB,GAAzB,UAA0B,KAA2B,EAAE,GAAW,EAAE,WAAyB,EAAE,iBAA0B;QACrH,8FAA8F;QAC9F,IAAI,QAAQ,GAAwB,WAAW,CAAC;QAChD,IAAI,aAAa,GAAG,KAAK,CAAC;QAE1B,OAAO,QAAQ,IAAI,CAAC,QAAQ,KAAK,WAAW,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC,EAAE;YAClF,2EAA2E;YAC3E,2EAA2E;YAC3E,mBAAmB;YACnB,IAAI,IAAI,CAAC,kBAAkB,CAAC,WAAW,EAAE,EAAE;gBACvC,IAAI,GAAG,KAAK,iBAAO,CAAC,IAAI,EAAE;oBACtB,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;iBAClD;aACJ;iBAAM,IAAI,GAAG,KAAK,iBAAO,CAAC,KAAK,EAAE;gBAC9B,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;aAClD;YAED,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,kBAAkB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;YAExE,gFAAgF;YAChF,aAAa,GAAG,iBAAO,CAAC,QAAQ,CAAC,CAAC;SACrC;QAED,IAAI,aAAa,IAAI,KAAK,IAAI,KAAK,CAAC,OAAO,KAAK,iBAAO,CAAC,EAAE,EAAE;YACxD,QAAQ,GAAG;gBACP,QAAQ,EAAE,CAAC,CAAC;gBACZ,SAAS,EAAE,IAAI;gBACf,MAAM,EAAE,WAAW,CAAC,MAAM;aAC7B,CAAC;SACL;QAED,gGAAgG;QAChG,kFAAkF;QAClF,IAAI,iBAAiB,EAAE;YACnB,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,yBAAyB,EAAE,CAAC;YACrE,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;gBAClB,IAAM,MAAM,GAA6B;oBACrC,GAAG,EAAE,GAAG;oBACR,oBAAoB,EAAE,WAAW;oBACjC,gBAAgB,EAAE,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI;oBAC5C,KAAK,EAAE,KAAK;iBACf,CAAC;gBACF,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAClC,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;oBAClB,IAAK,QAAgB,CAAC,QAAQ,EAAE;wBAC5B,iBAAM,CAAC,cAAQ,OAAO,CAAC,IAAI,CAAC,sJAAsJ,CAAC,CAAC,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC;wBACnN,QAAQ,CAAC,SAAS,GAAI,QAAgB,CAAC,QAAQ,CAAC;qBACnD;oBACD,QAAQ,GAAG;wBACP,SAAS,EAAE,QAAQ,CAAC,SAAS;wBAC7B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;wBAC3B,MAAM,EAAE,QAAQ,CAAC,MAAM;qBACV,CAAC;iBACrB;qBAAM;oBACH,QAAQ,GAAG,IAAI,CAAC;iBACnB;aACJ;SACJ;QAED,4FAA4F;QAC5F,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO;SAAE;QAE1B,IAAI,QAAQ,CAAC,QAAQ,GAAG,CAAC,EAAE;YACvB,IAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;YAEzE,IAAI,CAAC,eAAe,CAAC,mBAAmB,CACpC,EAAE,cAAc,EAAE,SAAS,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,MAAM,EAAE,CAClF,CAAC;YAEF,OAAO;SACV;QAED,yEAAyE;QACzE,yEAAyE;QACzE,IAAM,kBAAkB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;QAChE,IAAI,kBAAkB,EAAE;YACpB,IAAI,CAAC,aAAa,CAAC,kBAAkB,CAAC,CAAC;SAC1C;aAAM;YACH,IAAI,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;SACzC;IACL,CAAC;IAEO,2CAAqB,GAA7B,UAA8B,YAA0B;QACpD,sEAAsE;QACtE,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QACrC,IAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC;QAExD,+EAA+E;QAC/E,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE/B,YAAY,GAAG,QAAQ,CAAC,eAAe,EAAE,CAAC;QAC1C,iGAAiG;QACjG,+FAA+F;QAC/F,6FAA6F;QAC7F,+FAA+F;QAC/F,gBAAgB;QAChB,IAAI,CAAC,iBAAiB,CAAC,YAAY,CAAC,CAAC;QAErC,OAAO,YAAY,CAAC;IACxB,CAAC;IAEO,4CAAsB,GAA9B,UAA+B,QAAoC,EAAE,SAA0B;QAA1B,0BAAA,EAAA,iBAA0B;QAC3F,IAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,EAAE,CAAC;QACxE,IAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;QACnD,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEzD,IAAM,YAAY,GAAiB;YAC/B,QAAQ,EAAE,QAAQ,CAAC,QAAQ;YAC3B,SAAS,EAAE,QAAQ,CAAC,SAAS;YAC7B,MAAM,EAAG,QAAyB,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,YAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;SAC1G,CAAC;QAEF,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,CAAC;QAEjC,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,mCAAa,GAArB,UAAsB,YAA0B;QAC5C,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,YAAY,CAAC,QAAQ,EAAE,YAAY,CAAC,MAAM,EAAE,YAAY,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;QAE9G,IAAI,IAAI,CAAC,eAAe,EAAE;YACtB,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC;SACrD;IACL,CAAC;IAEO,yCAAmB,GAA3B,UAA4B,IAAkB;QAC1C,IAAM,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAEvD,8DAA8D;QAC9D,OAAO,CAAC,CAAC,OAAO,CAAC;IACrB,CAAC;IAEO,0CAAoB,GAA5B,UAA6B,IAAkB;QAC3C,IAAM,QAAQ,GAAG,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAEhD,IAAI,CAAC,QAAQ,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAE/B,IAAM,eAAe,GAAG,QAAQ,CAAC,kBAAkB,EAAE,CAAC;QAEtD,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;QAElD,OAAO;YACH,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,MAAM,EAAE,YAAI,CAAC,eAAe,CAAC;YAC7B,SAAS,EAAE,IAAI,CAAC,SAAS;SAC5B,CAAC;IACN,CAAC;IAEM,uCAAiB,GAAxB,UAAyB,QAAsB;QAC3C,iCAAiC;QACjC,IAAI,iBAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,kBAAkB,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;SAC7E;QAED,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE;YAC7B,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,mBAAmB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;SAC5E;QAED,iGAAiG;QACjG,6CAA6C;QAC7C,IAAI,CAAC,WAAW,CAAC,gBAAgB,EAAE,CAAC,+CAA+C,EAAE,CAAC;QAEtF,oEAAoE;QACpE,IAAI,CAAC,qBAAqB,CAAC,cAAc,EAAE,CAAC;IAChD,CAAC;IAEM,sCAAgB,GAAvB,UAAwB,QAAsB,EAAE,QAAwB,EAAE,SAAyB;QAC/F,IAAM,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;QAChD,IAAI,IAAI,EAAE;YACN,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;SAChD;IACL,CAAC;IAEM,yCAAmB,GAA1B,UAA2B,WAAwB;QAC/C,IAAI,YAAkC,CAAC;QACvC,QAAQ,WAAW,CAAC,SAAS,EAAE;YAC3B,KAAK,qBAAS,CAAC,UAAU;gBACrB,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBACrD,MAAM;YACV,KAAK,qBAAS,CAAC,aAAa;gBACxB,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBACxD,MAAM;YACV;gBACI,YAAY,GAAG,IAAI,CAAC,iBAAiB,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;gBAC5D,MAAM;SACb;QAED,OAAO,YAAY,CAAC;IACxB,CAAC;IAEM,yCAAmB,GAA1B,UAA2B,YAA0B;QACjD,IAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAC;QAEvD,IAAI,CAAC,OAAO,EAAE;YACV,OAAO,IAAI,CAAC;SACf;QAED,IAAM,aAAa,GAAI,OAAO,CAAC,wBAAwB,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAE7E,OAAO,aAAa,CAAC;IACzB,CAAC;IAEM,gCAAU,GAAjB,UAAkB,OAAoB;QAClC,QAAQ,OAAO,CAAC,SAAS,EAAE;YACvB,KAAK,qBAAS,CAAC,UAAU;gBACrB,OAAO,IAAI,CAAC,cAAc,CAAC,mBAAmB,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YACvE,KAAK,qBAAS,CAAC,aAAa;gBACxB,OAAO,IAAI,CAAC,cAAc,CAAC,sBAAsB,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;YAC1E;gBACI,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;SACrD;IACL,CAAC;IAED,2BAA2B;IACpB,kCAAY,GAAnB,UAAoB,oBAA8C,EAAE,aAA4B;QAC5F,IAAM,SAAS,GAAG,aAAa,CAAC,QAAQ,CAAC;QACzC,IAAM,eAAe,GAAG,IAAI,CAAC,mBAAmB,CAAC,oBAAoB,EAAE,SAAS,CAAC,CAAC;QAElF,IAAI,eAAe,EAAE;YACjB,oGAAoG;YACpG,mDAAmD;YACnD,aAAa,CAAC,cAAc,EAAE,CAAC;YAC/B,OAAO;SACV;QAED,gGAAgG;QAChG,aAAa;QACb,IAAI,SAAS,EAAE;YACL,IAAA,0CAA+D,EAA7D,sBAAQ,EAAE,wBAAmD,CAAC;YACtE,IAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,CAAC,CAAC,QAAQ,KAAK,IAAI,CAAC,eAAe,CAAC,eAAe,EAAE,CAAC;YAClG,IAAI,QAAQ,EAAE;gBACV,aAAa,CAAC,cAAc,EAAE,CAAC;gBAE/B,IAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,GAAG,CAAC,CAAC;gBAClF,IAAM,MAAM,GAAG,YAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,EAAE,CAAC,CAAC;gBAEpE,IAAI,CAAC,eAAe,CAAC,mBAAmB,CAAC,EAAE,cAAc,gBAAA,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;aACxE;SACJ;aAAM;YACH,yFAAyF;YACzF,sFAAsF;YACtF,iBAAiB;YACjB,IAAI,oBAAoB,YAAY,mBAAQ,EAAE;gBAC1C,oBAAoB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;aACxC;YAED,IAAI,IAAI,CAAC,eAAe,CAAC,0BAA0B,CAAC,KAAK,CAAC,EAAE;gBACxD,aAAa,CAAC,cAAc,EAAE,CAAC;aAClC;SACJ;IACL,CAAC;IAED,iBAAiB;IACV,mCAAa,GAApB,UAAqB,SAAkB;QACnC,IAAM,WAAW,GAAG,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,CAAC;QAC1D,oCAAoC;QACpC,IAAI,CAAC,WAAW,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEnC,IAAI,aAAa,GAAoC,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;QAE3F,sEAAsE;QACtE,8CAA8C;QAC9C,IAAI,CAAC,aAAa,EAAE;YAChB,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;YACtD,IAAI,CAAC,aAAa,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE;gBAChD,OAAO,KAAK,CAAC;aAChB;SACJ;QAED,OAAO,IAAI,CAAC,mBAAmB,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;IAC9D,CAAC;IAEO,yCAAmB,GAA3B,UAA4B,iBAA2C,EAAE,SAAkB;QACvF,IAAI,OAAO,GAAG,iBAAiB,CAAC,SAAS,EAAE,CAAC;QAE5C,wFAAwF;QACxF,IAAI,CAAC,OAAO,IAAI,iBAAiB,YAAY,mBAAQ,EAAE;YACnD,IAAM,QAAQ,GAAG,iBAA6B,CAAC;YAC/C,IAAM,MAAM,GAAG,QAAQ,CAAC,cAAc,EAAE,CAAC;YACzC,IAAI,MAAM,EAAE;gBACR,OAAO,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;aAChC;SACJ;QAED,IAAI,GAAY,CAAC;QAEjB,IAAI,OAAO,EAAE;YACT,iEAAiE;YACjE,IAAI,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,EAAE;gBACzC,GAAG,GAAG,IAAI,CAAC,oBAAoB,CAAC,iBAA6B,EAAE,SAAS,CAAC,CAAC;aAC7E;iBAAM;gBACH,GAAG,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAA6B,EAAE,SAAS,CAAC,CAAC;aAC9E;SACJ;aAAM;YACH,GAAG,GAAG,IAAI,CAAC,wBAAwB,CAAC,iBAAiB,EAAE,SAAS,CAAC,CAAC;SACrE;QAED,2EAA2E;QAC3E,OAAO,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,CAAC;IAC5D,CAAC;IAEO,2CAAqB,GAA7B,UAA8B,oBAA8B,EAAE,SAAkB;QAC5E,IAAM,QAAQ,GAAG,oBAAoB,CAAC,eAAe,EAAE,CAAC;QAExD,0EAA0E;QAC1E,2EAA2E;QAC3E,4EAA4E;QAC5E,2CAA2C;QAC3C,oBAAoB,CAAC,WAAW,EAAE,CAAC;QAEnC,sCAAsC;QACtC,IAAM,gBAAgB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,SAAS,EAAE,IAAI,CAAa,CAAC;QAC3F,IAAM,SAAS,GAAG,gBAAgB,IAAI,IAAI,CAAC;QAE3C,oGAAoG;QACpG,mDAAmD;QACnD,IAAI,SAAS,EAAE;YACX,gBAAgB,CAAC,qBAAqB,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;YACzD,gBAAgB,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;SACrC;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAEO,0CAAoB,GAA5B,UAA6B,gBAA0B,EAAE,SAAkB;QACvE,IAAM,OAAO,GAAG,gBAAgB,CAAC,eAAe,EAAE,CAAC;QACnD,sCAAsC;QACtC,IAAM,YAAY,GAAG,IAAI,CAAC,qBAAqB,CAAC,OAAO,EAAE,SAAS,EAAE,IAAI,CAAa,CAAC;QAEtF,IAAI,YAAY,IAAI,IAAI,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAE3C,IAAM,WAAW,GAAG,gBAAgB,CAAC,eAAe,EAAE,CAAC;QACvD,IAAM,OAAO,GAAG,YAAY,CAAC,eAAe,EAAE,CAAC;QAE/C,IAAM,gBAAgB,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,CAAC;QAC1D,IAAM,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;QAElD,IAAM,SAAS,GAAG,OAAO,IAAI,WAAW,CAAC,QAAQ,KAAK,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC;QAEtH,IAAI,gBAAgB,EAAE;YAClB,gBAAgB,CAAC,mBAAmB,EAAE,CAAC;SAC1C;QAED,IAAI,CAAC,SAAS,EAAE;YACZ,IAAM,IAAI,GAAG,gBAAgB,CAAC,cAAc,EAAE,CAAC;YAC/C,IAAK,CAAC,WAAW,EAAE,CAAC;YAEpB,IAAM,IAAI,GAAG,YAAY,CAAC,cAAc,EAAE,CAAC;YAC3C,IAAK,CAAC,eAAe,EAAE,CAAC;SAC3B;QAED,IAAI,YAAY,EAAE;YACd,YAAY,CAAC,kBAAkB,EAAE,CAAC;YAClC,YAAY,CAAC,SAAS,EAAE,CAAC;SAC5B;aAAM;YACH,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SAChC;QAED,OAAO,IAAI,CAAC;IAChB,CAAC;IAEO,8CAAwB,GAAhC,UAAiC,oBAA8C,EAAE,SAAkB;QAC/F,IAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,EAAE,CAAC;QACxE,IAAI,QAAsB,CAAC;QAE3B,IAAI,oBAAoB,YAAY,6BAAa,EAAE;YAC/C,QAAQ,yBACD,oBAAoB,CAAC,cAAc,EAAE,KACxC,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,YAAI,CAAC,gBAAgB,CAAC,GACnE,CAAC;SACL;aAAM;YACH,QAAQ,GAAG,oBAAoB,CAAC,eAAe,EAAE,CAAC;SACrD;QACD,sCAAsC;QACtC,IAAM,gBAAgB,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;QAEhF,oGAAoG;QACpG,mDAAmD;QACnD,IAAI,gBAAgB,YAAY,mBAAQ,EAAE;YACtC,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SACpC;aAAM,IAAI,gBAAgB,EAAE;YACzB,OAAO,IAAI,CAAC,sBAAsB,CAAC,gBAAgB,CAAC,cAAc,EAAE,EAAE,SAAS,CAAC,CAAC;SACpF;QAED,OAAO,gBAAM,CAAC,gBAAgB,CAAC,CAAC;IACpC,CAAC;IAED,yDAAyD;IACzD,mEAAmE;IAC3D,2CAAqB,GAA7B,UAA8B,QAAsB,EAAE,SAAkB,EAAE,YAAqB;QAC3F,IAAI,QAAQ,GAAwB,QAAQ,CAAC;QAE7C,OAAO,IAAI,EAAE;YACT,IAAI,CAAC,SAAS,EAAE;gBACZ,QAAQ,GAAG,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,CAAC;aAClD;YACD,QAAQ,GAAG,IAAI,CAAC,qBAAqB,CAAC,iBAAiB,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YAE7E,iDAAiD;YACjD,IAAM,QAAQ,GAAG,IAAI,CAAC,kBAAkB,CAAC,oBAAoB,EAAE,CAAC;YAEhE,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;gBAClB,IAAM,MAAM,GAAG;oBACX,SAAS,EAAE,SAAS;oBACpB,OAAO,EAAE,YAAY;oBACrB,oBAAoB,EAAE,QAAQ;oBAC9B,gBAAgB,EAAE,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI;iBACxB,CAAC;gBACzB,IAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;gBAClC,IAAI,gBAAM,CAAC,QAAQ,CAAC,EAAE;oBAClB,IAAK,QAAgB,CAAC,QAAQ,EAAE;wBAC5B,iBAAM,CAAC,cAAQ,OAAO,CAAC,IAAI,CAAC,sJAAsJ,CAAC,CAAC,CAAC,CAAC,EAAE,yBAAyB,CAAC,CAAC;wBACnN,QAAQ,CAAC,SAAS,GAAI,QAAgB,CAAC,QAAQ,CAAC;qBACnD;oBACD,QAAQ,GAAG;wBACP,QAAQ,EAAE,QAAQ,CAAC,QAAQ;wBAC3B,MAAM,EAAE,QAAQ,CAAC,MAAM;wBACvB,SAAS,EAAE,QAAQ,CAAC,SAAS;qBAChB,CAAC;iBACrB;qBAAM;oBACH,QAAQ,GAAG,IAAI,CAAC;iBACnB;aACJ;YAED,oFAAoF;YACpF,mEAAmE;YACnE,IAAI,CAAC,QAAQ,EAAE;gBAAE,OAAO,IAAI,CAAC;aAAE;YAE/B,IAAI,QAAQ,CAAC,QAAQ,GAAG,CAAC,EAAE;gBACvB,IAAM,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,iBAAiB,EAAE,CAAC;gBAEzE,IAAI,CAAC,eAAe,CAAC,mBAAmB,CACpC,EAAE,cAAc,EAAE,SAAS,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,MAAM,EAAE,QAAQ,CAAC,MAAM,EAAE,CAC/E,CAAC;gBAEF,OAAO,IAAI,CAAC;aACf;YAED,+EAA+E;YAC/E,kFAAkF;YAClF,sFAAsF;YACtF,oEAAoE;YACpE,2FAA2F;YAC3F,IAAM,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,aAAa,EAAE,CAAC;YAC5D,IAAI,YAAY,IAAI,CAAC,WAAW,EAAE;gBAC9B,IAAM,cAAc,GAAG,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;gBACrD,IAAI,CAAC,cAAc,EAAE;oBAAE,SAAS;iBAAE;aACrC;YAED,IAAI,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;YAEjC,0FAA0F;YAC1F,+EAA+E;YAC/E,IAAM,YAAY,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;YAExD,wDAAwD;YACxD,iDAAiD;YACjD,IAAI,CAAC,YAAY,EAAE;gBACf,IAAM,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAC;gBACnD,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE;oBACpC,SAAS;iBACZ;qBAAM;oBACH,OAAO,OAAO,CAAC;iBAClB;aACJ;YAED,IAAI,YAAY,CAAC,mBAAmB,EAAE,EAAE;gBAAE,SAAS;aAAE;YAErD,kGAAkG;YAClG,2CAA2C;YAC3C,IAAI,IAAI,CAAC,eAAe,EAAE;gBACtB,IAAI,CAAC,eAAe,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;aACjD;YAED,0DAA0D;YAC1D,OAAO,YAAY,CAAC;SACvB;IACL,CAAC;IAEO,oCAAc,GAAtB,UAAuB,IAAkB;QACrC,IAAM,OAAO,GAAG,IAAI,CAAC,oBAAoB,CAAC,IAAI,CAAC,CAAC;QAEhD,IAAI,OAAO,EAAE;YACT,OAAO,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;SAC9C;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAEO,0CAAoB,GAA5B,UAA6B,IAAkB;QAC3C,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAS,CAAC,UAAU,EAAE;YACzC,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAC7D;QAED,IAAI,IAAI,CAAC,SAAS,KAAK,qBAAS,CAAC,aAAa,EAAE;YAC5C,OAAO,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;SAChE;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IACtD,CAAC;IAED,+EAA+E;IAC/E,sEAAsE;IAC/D,+CAAyB,GAAhC,UAAiC,UAAkB,EAAE,QAAgB;QAEjE,yFAAyF;QACzF,IAAM,YAAY,GAAG,UAAU,IAAI,IAAI,IAAI,QAAQ,IAAI,IAAI,CAAC;QAC5D,IAAI,YAAY,EAAE;YAAE,OAAO,KAAK,CAAC;SAAE;QAEnC,IAAM,kBAAkB,GAAG,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC;QAC7D,IAAM,mBAAmB,GAAG,QAAQ,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC7D,IAAM,mBAAmB,GAAG,CAAC,mBAAmB,IAAI,CAAC,kBAAkB,CAAC;QAExE,OAAO,mBAAmB,CAAC;IAC/B,CAAC;IApnD6B;QAA7B,mBAAS,CAAC,iBAAiB,CAAC;wDAA0C;IACxC;QAA9B,mBAAS,CAAC,kBAAkB,CAAC;yDAA4C;IACrD;QAApB,mBAAS,CAAC,QAAQ,CAAC;+CAAqB;IACZ;QAA5B,mBAAS,CAAC,gBAAgB,CAAC;uDAAwC;IAC7C;QAAtB,mBAAS,CAAC,UAAU,CAAC;iDAA6B;IACrB;QAA7B,mBAAS,CAAC,iBAAiB,CAAC;wDAA0C;IACnC;QAAnC,mBAAS,CAAC,uBAAuB,CAAC;8DAAsD;IACjE;QAAvB,mBAAS,CAAC,WAAW,CAAC;kDAA8B;IAC/B;QAArB,mBAAS,CAAC,SAAS,CAAC;gDAA0B;IAC3B;QAAnB,mBAAS,CAAC,OAAO,CAAC;8CAAsB;IACD;QAAvC,mBAAS,CAAC,2BAA2B,CAAC;kEAA8D;IACjE;QAAnC,mBAAS,CAAC,uBAAuB,CAAC;8DAAsD;IAC1D;QAA9B,mBAAS,CAAC,kBAAkB,CAAC;yDAA4C;IAC7C;QAA5B,kBAAQ,CAAC,iBAAiB,CAAC;wDAA2C;IACvC;QAA/B,kBAAQ,CAAC,oBAAoB,CAAC;2DAAgD;IAiC/E;QAAe,WAAA,mBAAS,CAAC,eAAe,CAAC,CAAA;6CAExC;IAGD;QADC,uBAAa;oDAMb;IA3DQ,WAAW;QADvB,cAAI,CAAC,aAAa,CAAC;OACP,WAAW,CAunDvB;IAAD,kBAAC;CAvnDD,AAunDC,CAvnDgC,mBAAQ,GAunDxC;AAvnDY,kCAAW","file":"rowRenderer.js","sourcesContent":["import { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { RowController } from \"./row/rowController\";\nimport { Column } from \"../entities/column\";\nimport { RowNode } from \"../entities/rowNode\";\nimport {\n    CellFocusedEvent,\n    DisplayedRowsChangedEvent,\n    Events,\n    FirstDataRenderedEvent,\n    ModelUpdatedEvent,\n    ViewportChangedEvent\n} from \"../events\";\nimport { Constants } from \"../constants/constants\";\nimport { CellComp } from \"./cellComp\";\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from \"../context/context\";\nimport { ColumnApi } from \"../columnController/columnApi\";\nimport { ColumnController } from \"../columnController/columnController\";\nimport { Logger, LoggerFactory } from \"../logger\";\nimport { FocusController } from \"../focusController\";\nimport { IRangeController } from \"../interfaces/iRangeController\";\nimport { CellNavigationService } from \"../cellNavigationService\";\nimport { CellPosition } from \"../entities/cellPosition\";\nimport { NavigateToNextCellParams, TabToNextCellParams } from \"../entities/gridOptions\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { PaginationProxy } from \"../pagination/paginationProxy\";\nimport { FlashCellsParams, GetCellRendererInstancesParams, GridApi, RefreshCellsParams } from \"../gridApi\";\nimport { Beans } from \"./beans\";\nimport { AnimationFrameService } from \"../misc/animationFrameService\";\nimport { RowContainerHeightService } from \"./rowContainerHeightService\";\nimport { ICellRendererComp } from \"./cellRenderers/iCellRenderer\";\nimport { ICellEditorComp } from \"../interfaces/iCellEditor\";\nimport { IRowModel } from \"../interfaces/iRowModel\";\nimport { RowPosition, RowPositionUtils } from \"../entities/rowPosition\";\nimport { PinnedRowModel } from \"../pinnedRowModel/pinnedRowModel\";\nimport { exists, missing } from \"../utils/generic\";\nimport { getAllValuesInObject, iterateObject } from \"../utils/object\";\nimport { createArrayOfNumbers } from \"../utils/number\";\nimport { last } from \"../utils/array\";\nimport { doOnce, executeInAWhile } from \"../utils/function\";\nimport { KeyCode } from '../constants/keyCode';\nimport { ControllersService } from \"../controllersService\";\nimport { GridBodyController } from \"../gridBodyComp/gridBodyController\";\n\nexport interface RowMap {\n    [key: string]: RowController;\n}\n\n@Bean(\"rowRenderer\")\nexport class RowRenderer extends BeanStub {\n\n    @Autowired(\"paginationProxy\") private paginationProxy: PaginationProxy;\n    @Autowired(\"columnController\") private columnController: ColumnController;\n    @Autowired(\"$scope\") private $scope: any;\n    @Autowired(\"pinnedRowModel\") private pinnedRowModel: PinnedRowModel;\n    @Autowired(\"rowModel\") private rowModel: IRowModel;\n    @Autowired(\"focusController\") private focusController: FocusController;\n    @Autowired(\"cellNavigationService\") private cellNavigationService: CellNavigationService;\n    @Autowired(\"columnApi\") private columnApi: ColumnApi;\n    @Autowired(\"gridApi\") private gridApi: GridApi;\n    @Autowired(\"beans\") private beans: Beans;\n    @Autowired(\"rowContainerHeightService\") private rowContainerHeightService: RowContainerHeightService;\n    @Autowired(\"animationFrameService\") private animationFrameService: AnimationFrameService;\n    @Autowired(\"rowPositionUtils\") private rowPositionUtils: RowPositionUtils;\n    @Optional(\"rangeController\") private rangeController: IRangeController;\n    @Optional(\"controllersService\") private controllersService: ControllersService;\n\n    // private gridBodyComp: GridBodyComp;\n    private gridBodyCon: GridBodyController;\n\n    private destroyFuncsForColumnListeners: (() => void)[] = [];\n\n    private firstRenderedRow: number;\n    private lastRenderedRow: number;\n\n    // map of row ids to row objects. keeps track of which elements\n    // are rendered for which rows in the dom.\n    private rowConsByRowIndex: RowMap = {};\n    private zombieRowCons: RowMap = {};\n    private allRowCons: RowController[] = [];\n\n    private topRowCons: RowController[] = [];\n    private bottomRowCons: RowController[] = [];\n\n    private pinningLeft: boolean;\n    private pinningRight: boolean;\n\n    // we only allow one refresh at a time, otherwise the internal memory structure here\n    // will get messed up. this can happen if the user has a cellRenderer, and inside the\n    // renderer they call an API method that results in another pass of the refresh,\n    // then it will be trying to draw rows in the middle of a refresh.\n    private refreshInProgress = false;\n\n    private logger: Logger;\n\n    private printLayout: boolean;\n    private embedFullWidthRows: boolean;\n\n    public agWire(@Qualifier(\"loggerFactory\") loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create(\"RowRenderer\");\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.controllersService.whenReady(() => {\n            this.gridBodyCon = this.controllersService.getGridBodyController();\n            this.initialise();\n        });\n    }\n\n    private initialise(): void {\n        this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onNewColumnsLoaded.bind(this));\n\n        this.registerCellEventListeners();\n\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n\n        this.redrawAfterModelUpdate();\n    }\n\n    public getRowCons(): RowController[] {\n        return this.allRowCons;\n    }\n\n    private updateAllRowCons(): void {\n        this.allRowCons = [...getAllValuesInObject(this.rowConsByRowIndex), ...getAllValuesInObject(this.zombieRowCons)];\n    }\n\n    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n    // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n    // all active cells.\n    private registerCellEventListeners(): void {\n        this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, (event: CellFocusedEvent) => {\n            this.forEachCellComp(cellComp => cellComp.onCellFocused(event));\n            this.forEachRowComp((key: string, rowComp: RowController) => {\n                if (rowComp.isFullWidth()) {\n                    rowComp.onFullWidthRowFocused(event);\n                }\n            });\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, event => {\n            this.forEachCellComp(cellComp => cellComp.onFlashCells(event));\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, () => {\n            this.forEachCellComp(cellComp => cellComp.onColumnHover());\n        });\n\n        // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n        // then changing the width of the containers will impact left position. eg the center cols all have their\n        // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n        // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n        // in different containers so doesn't impact.\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, () => {\n            if (this.printLayout) {\n                this.forEachCellComp(cellComp => cellComp.onLeftChanged());\n            }\n        });\n\n        const rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n        if (rangeSelectionEnabled) {\n\n            this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, () => {\n                this.forEachCellComp(cellComp => cellComp.onRangeSelectionChanged());\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, () => {\n                this.forEachCellComp(cellComp => cellComp.updateRangeBordersIfRangeCount());\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, () => {\n                this.forEachCellComp(cellComp => cellComp.updateRangeBordersIfRangeCount());\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, () => {\n                this.forEachCellComp(cellComp => cellComp.updateRangeBordersIfRangeCount());\n            });\n\n        }\n\n        // add listeners to the grid columns\n        this.refreshListenersToColumnsForCellComps();\n        // if the grid columns change, then refresh the listeners again\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n\n        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n    }\n\n    // executes all functions in destroyFuncsForColumnListeners and then clears the list\n    private removeGridColumnListeners(): void {\n        this.destroyFuncsForColumnListeners.forEach(func => func());\n        this.destroyFuncsForColumnListeners.length = 0;\n    }\n\n    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n    // once instead.\n    private refreshListenersToColumnsForCellComps(): void {\n        this.removeGridColumnListeners();\n\n        const cols = this.columnController.getAllGridColumns();\n\n        if (!cols) { return; }\n\n        cols.forEach(col => {\n            const forEachCellWithThisCol = (callback: (cellComp: CellComp) => void) => {\n                this.forEachCellComp(cellComp => {\n                    if (cellComp.getColumn() === col) {\n                        callback(cellComp);\n                    }\n                });\n            };\n\n            const leftChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onLeftChanged());\n            };\n            const widthChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onWidthChanged());\n            };\n            const firstRightPinnedChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onFirstRightPinnedChanged());\n            };\n            const lastLeftPinnedChangedListener = () => {\n                forEachCellWithThisCol(cellComp => cellComp.onLastLeftPinnedChanged());\n            };\n\n            col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n            col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n            col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n            col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n\n            this.destroyFuncsForColumnListeners.push(() => {\n                col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n                col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n                col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n                col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            });\n        });\n\n    }\n\n    private onDomLayoutChanged(): void {\n        const printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        const embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n\n        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n        // out using absolute positioning when doing print layout\n        const destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n\n        this.printLayout = printLayout;\n        this.embedFullWidthRows = embedFullWidthRows;\n\n        if (destroyRows) {\n            this.redrawAfterModelUpdate();\n        }\n    }\n\n    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n    public datasourceChanged(): void {\n        this.firstRenderedRow = 0;\n        this.lastRenderedRow = -1;\n        const rowIndexesToRemove = Object.keys(this.rowConsByRowIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    }\n\n    private onPageLoaded(event: ModelUpdatedEvent): void {\n        const params: RefreshViewParams = {\n            recycleRows: event.keepRenderedRows,\n            animate: event.animate,\n            newData: event.newData,\n            newPage: event.newPage,\n            // because this is a model updated event (not pinned rows), we\n            // can skip updating the pinned rows. this is needed so that if user\n            // is doing transaction updates, the pinned rows are not getting constantly\n            // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n            onlyBody: true\n        };\n        this.redrawAfterModelUpdate(params);\n    }\n\n    public getAllCellsForColumn(column: Column): HTMLElement[] {\n        const eCells: HTMLElement[] = [];\n\n        function callback(key: any, rowComp: RowController) {\n            const eCell = rowComp.getCellForCol(column);\n            if (eCell) { eCells.push(eCell); }\n        }\n\n        iterateObject(this.rowConsByRowIndex, callback);\n        iterateObject(this.bottomRowCons, callback);\n        iterateObject(this.topRowCons, callback);\n\n        return eCells;\n    }\n\n    public refreshFloatingRowComps(): void {\n        this.refreshFloatingRows(\n            this.topRowCons,\n            this.pinnedRowModel.getPinnedTopRowData()\n        );\n\n        this.refreshFloatingRows(\n            this.bottomRowCons,\n            this.pinnedRowModel.getPinnedBottomRowData()\n        );\n    }\n\n    public getTopRowCons(): RowController[] {\n        return this.topRowCons;\n    }\n\n    public getBottomRowCons(): RowController[] {\n        return this.bottomRowCons;\n    }\n\n    private refreshFloatingRows(rowComps: RowController[], rowNodes: RowNode[]): void {\n        rowComps.forEach((row: RowController) => {\n            row.destroyFirstPass();\n            row.destroySecondPass();\n        });\n\n        rowComps.length = 0;\n\n        if (!rowNodes) { return; }\n\n        rowNodes.forEach(rowNode => {\n            const rowCon = new RowController(\n                this.$scope,\n                rowNode,\n                this.beans,\n                false,\n                false,\n                this.printLayout\n            );\n\n            rowComps.push(rowCon);\n        });\n    }\n\n    private onPinnedRowDataChanged(): void {\n        // recycling rows in order to ensure cell editing is not cancelled\n        const params: RefreshViewParams = {\n            recycleRows: true\n        };\n\n        this.redrawAfterModelUpdate(params);\n    }\n\n    // if the row nodes are not rendered, no index is returned\n    private getRenderedIndexesForRowNodes(rowNodes: RowNode[]): string[] {\n        const result: string[] = [];\n\n        if (missing(rowNodes)) { return result; }\n\n        iterateObject(this.rowConsByRowIndex, (index: string, renderedRow: RowController) => {\n            const rowNode = renderedRow.getRowNode();\n            if (rowNodes.indexOf(rowNode) >= 0) {\n                result.push(index);\n            }\n        });\n\n        return result;\n    }\n\n    public redrawRows(rowNodes?: RowNode[]): void {\n        // if no row nodes provided, then refresh everything\n        const partialRefresh = rowNodes != null && rowNodes.length > 0;\n\n        if (partialRefresh) {\n            const indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes!);\n            // remove the rows\n            this.removeRowComps(indexesToRemove);\n        }\n\n        // add draw them again\n        this.redrawAfterModelUpdate({\n            recycleRows: partialRefresh\n        });\n    }\n\n    private getCellToRestoreFocusToAfterRefresh(params: RefreshViewParams): CellPosition | null {\n        const focusedCell = params.suppressKeepFocus ? null : this.focusController.getFocusCellToUseAfterRefresh();\n\n        if (missing(focusedCell)) { return null; }\n\n        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n        // cell itself, then the cell can be registered as having focus, however it's the text field that\n        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n        // the focus is lost from the text field. we do not want this.\n        const activeElement = document.activeElement;\n        const domData = this.gridOptionsWrapper.getDomData(activeElement, CellComp.DOM_DATA_KEY_CELL_COMP);\n        const elementIsNotACellDev = missing(domData);\n\n        return elementIsNotACellDev ? null : focusedCell;\n    }\n\n    // gets called from:\n    // +) initialisation (in registerGridComp) params = null\n    // +) onDomLayoutChanged, params = null\n    // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true\n    // +) onPinnedRowDataChanged, recycleRows = true\n    // +) redrawRows (from Grid API), recycleRows = true/false\n    private redrawAfterModelUpdate(params: RefreshViewParams = {}): void {\n        this.getLockOnRefresh();\n\n        const focusedCell: CellPosition | null = this.getCellToRestoreFocusToAfterRefresh(params);\n\n        this.updateContainerHeights();\n        this.scrollToTopIfNewData(params);\n\n        // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n        // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n        const recycleRows = !this.printLayout && !!params.recycleRows;\n        const animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n\n        // after modelUpdate, row indexes can change, so we clear out the rowsByIndex map,\n        // however we can reuse the rows, so we keep them but index by rowNode.id\n        const rowsToRecycle = recycleRows ? this.recycleRows() : null;\n        if (!recycleRows) {\n            this.removeAllRowComps();\n        }\n\n        const isFocusedCellGettingRecycled = () => {\n            if (focusedCell == null || rowsToRecycle == null) { return false; }\n            let res = false;\n\n            iterateObject(rowsToRecycle, (key: string, rowComp: RowController) => {\n                const rowNode = rowComp.getRowNode();\n                const rowIndexEqual = rowNode.rowIndex == focusedCell.rowIndex;\n                const pinnedEqual = rowNode.rowPinned == focusedCell.rowPinned;\n                if (rowIndexEqual && pinnedEqual) {\n                    res = true;\n                }\n            });\n\n            return res;\n        };\n\n        const focusedCellRecycled = isFocusedCellGettingRecycled();\n\n        this.redraw(rowsToRecycle, animate);\n\n        if (!params.onlyBody) {\n            this.refreshFloatingRowComps();\n        }\n\n        this.dispatchDisplayedRowsChanged();\n\n        // if we focus a cell that's already focused, then we get an unnecessary 'cellFocused' event fired.\n        // this was happening when user clicked 'expand' on a rowGroup, then cellFocused was getting fired twice.\n        if (!focusedCellRecycled) {\n            this.restoreFocusedCell(focusedCell);\n        }\n\n        this.releaseLockOnRefresh();\n    }\n\n    private scrollToTopIfNewData(params: RefreshViewParams): void {\n        const scrollToTop = params.newData || params.newPage;\n        const suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n\n        if (scrollToTop && !suppressScrollToTop) {\n            this.gridBodyCon.getScrollFeature().scrollToTop();\n        }\n    }\n\n    private updateContainerHeights(): void {\n        // when doing print layout, we don't explicitly set height on the containers\n        if (this.printLayout) {\n            this.rowContainerHeightService.setModelHeight(null);\n            return;\n        }\n\n        let containerHeight = this.paginationProxy.getCurrentPageHeight();\n        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n        // we still want the scroll to be present, otherwise there would be no way to scroll the header\n        // which might be needed us user wants to access columns\n        // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n        // is no way to remove the filter.\n        if (containerHeight === 0) {\n            containerHeight = 1;\n        }\n\n        this.rowContainerHeightService.setModelHeight(containerHeight);\n    }\n\n    private getLockOnRefresh(): void {\n        if (this.refreshInProgress) {\n            throw new Error(\n                \"AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" +\n                \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" +\n                \"this, put the API call into a timeout, e.g. instead of api.refreshView(), \" +\n                \"call setTimeout(function() { api.refreshView(); }, 0). To see what part of your code \" +\n                \"that caused the refresh check this stacktrace.\"\n            );\n        }\n\n        this.refreshInProgress = true;\n    }\n\n    private releaseLockOnRefresh(): void {\n        this.refreshInProgress = false;\n    }\n\n    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n    // edited cell).\n    private restoreFocusedCell(cellPosition: CellPosition | null): void {\n        if (cellPosition) {\n            this.focusController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        }\n    }\n\n    public stopEditing(cancel: boolean = false) {\n        this.forEachRowComp((key: string, rowComp: RowController) => {\n            rowComp.stopEditing(cancel);\n        });\n    }\n\n    private onNewColumnsLoaded(): void {\n        // we don't want each cellComp to register for events, as would increase rendering time.\n        // so for newColumnsLoaded, we register once here (in rowRenderer) and then inform\n        // each cell if / when event was fired.\n        this.forEachCellComp(cellComp => cellComp.onNewColumnsLoaded());\n    }\n\n    public forEachCellComp(callback: (cellComp: CellComp) => void): void {\n        this.forEachRowComp((key: string, rowComp: RowController) => rowComp.forEachCellComp(callback));\n    }\n\n    private forEachRowComp(callback: (key: string, rowComp: RowController) => void): void {\n        iterateObject(this.rowConsByRowIndex, callback);\n        iterateObject(this.topRowCons, callback);\n        iterateObject(this.bottomRowCons, callback);\n    }\n\n    public addRenderedRowListener(eventName: string, rowIndex: number, callback: Function): void {\n        const rowComp = this.rowConsByRowIndex[rowIndex];\n        if (rowComp) {\n            rowComp.addEventListener(eventName, callback);\n        }\n    }\n\n    public flashCells(params: FlashCellsParams = {}): void {\n        const { flashDelay, fadeDelay } = params;\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => cellComp.flashCell({ flashDelay, fadeDelay }));\n    }\n\n    public refreshCells(params: RefreshCellsParams = {}): void {\n        const refreshCellParams = {\n            forceRefresh: params.force,\n            newData: false,\n            suppressFlash: params.suppressFlash\n        };\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => {\n            if (cellComp.refreshShouldDestroy()) {\n                const rowComp = cellComp.getRenderedRow();\n                if (rowComp) {\n                    rowComp.refreshCell(cellComp);\n                }\n            } else {\n                cellComp.refreshCell(refreshCellParams);\n            }\n        });\n    }\n\n    public getCellRendererInstances(params: GetCellRendererInstancesParams): ICellRendererComp[] {\n\n        const res: ICellRendererComp[] = [];\n\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => {\n            const cellRenderer = cellComp.getCellRenderer();\n\n            if (cellRenderer) {\n                res.push(cellRenderer);\n            }\n        });\n\n        return res;\n    }\n\n    public getCellEditorInstances(params: GetCellRendererInstancesParams): ICellEditorComp[] {\n\n        const res: ICellEditorComp[] = [];\n\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, cellComp => {\n            const cellEditor = cellComp.getCellEditor();\n\n            if (cellEditor) {\n                res.push(cellEditor);\n            }\n        });\n\n        return res;\n    }\n\n    public getEditingCells(): CellPosition[] {\n        const res: CellPosition[] = [];\n\n        this.forEachCellComp(cellComp => {\n            if (cellComp.isEditing()) {\n                const cellPosition = cellComp.getCellPosition();\n                res.push(cellPosition);\n            }\n        });\n\n        return res;\n    }\n\n    // calls the callback for each cellComp that match the provided rowNodes and columns. eg if one row node\n    // and two columns provided, that identifies 4 cells, so callback gets called 4 times, once for each cell.\n    private forEachCellCompFiltered(rowNodes?: RowNode[] | null, columns?: (string | Column)[], callback?: (cellComp: CellComp) => void): void {\n        let rowIdsMap: any;\n\n        if (exists(rowNodes)) {\n            rowIdsMap = {\n                top: {},\n                bottom: {},\n                normal: {}\n            };\n\n            rowNodes.forEach(rowNode => {\n                const id = rowNode.id!;\n                if (rowNode.rowPinned === Constants.PINNED_TOP) {\n                    rowIdsMap.top[id] = true;\n                } else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n                    rowIdsMap.bottom[id] = true;\n                } else {\n                    rowIdsMap.normal[id] = true;\n                }\n            });\n        }\n\n        let colIdsMap: any;\n\n        if (exists(columns)) {\n            colIdsMap = {};\n            columns.forEach((colKey: string | Column) => {\n                const column: Column | null = this.columnController.getGridColumn(colKey);\n                if (exists(column)) {\n                    colIdsMap[column.getId()] = true;\n                }\n            });\n        }\n\n        const processRow = (rowComp: RowController) => {\n            const rowNode: RowNode = rowComp.getRowNode();\n            const id = rowNode.id!;\n            const floating = rowNode.rowPinned;\n\n            // skip this row if it is missing from the provided list\n            if (exists(rowIdsMap)) {\n                if (floating === Constants.PINNED_BOTTOM) {\n                    if (!rowIdsMap.bottom[id]) {\n                        return;\n                    }\n                } else if (floating === Constants.PINNED_TOP) {\n                    if (!rowIdsMap.top[id]) {\n                        return;\n                    }\n                } else {\n                    if (!rowIdsMap.normal[id]) {\n                        return;\n                    }\n                }\n            }\n\n            rowComp.forEachCellComp(cellComp => {\n                const colId: string = cellComp.getColumn().getId();\n                const excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n\n                if (excludeColFromRefresh) { return; }\n                if (callback) { callback(cellComp); }\n            });\n        };\n\n        iterateObject(this.rowConsByRowIndex, (index: string, rowComp: RowController) => {\n            processRow(rowComp);\n        });\n\n        if (this.topRowCons) {\n            this.topRowCons.forEach(processRow);\n        }\n\n        if (this.bottomRowCons) {\n            this.bottomRowCons.forEach(processRow);\n        }\n    }\n\n    protected destroy(): void {\n        this.removeAllRowComps();\n        super.destroy();\n    }\n\n    private removeAllRowComps(): void {\n        const rowIndexesToRemove = Object.keys(this.rowConsByRowIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    }\n\n    private recycleRows(): RowMap {\n        // remove all stub nodes, they can't be reused, as no rowNode id\n        const stubNodeIndexes: string[] = [];\n        iterateObject(this.rowConsByRowIndex, (index: string, rowComp: RowController) => {\n            const stubNode = rowComp.getRowNode().id == null;\n            if (stubNode) {\n                stubNodeIndexes.push(index);\n            }\n        });\n        this.removeRowComps(stubNodeIndexes);\n\n        // then clear out rowCompsByIndex, but before that take a copy, but index by id, not rowIndex\n        const nodesByIdMap: RowMap = {};\n        iterateObject(this.rowConsByRowIndex, (index: string, rowComp: RowController) => {\n            const rowNode = rowComp.getRowNode();\n            nodesByIdMap[rowNode.id!] = rowComp;\n        });\n        this.rowConsByRowIndex = {};\n\n        return nodesByIdMap;\n    }\n\n    // takes array of row indexes\n    private removeRowComps(rowsToRemove: any[]) {\n        // if no fromIndex then set to -1, which will refresh everything\n        // let realFromIndex = -1;\n        rowsToRemove.forEach(indexToRemove => {\n            const rowComp = this.rowConsByRowIndex[indexToRemove];\n            if (rowComp) {\n                rowComp.destroyFirstPass();\n                rowComp.destroySecondPass();\n            }\n            delete this.rowConsByRowIndex[indexToRemove];\n        });\n    }\n\n    // gets called when rows don't change, but viewport does, so after:\n    // 1) height of grid body changes, ie number of displayed rows has changed\n    // 2) grid scrolled to new position\n    // 3) ensure index visible (which is a scroll)\n    public redrawAfterScroll() {\n        this.getLockOnRefresh();\n        this.redraw(null, false, true);\n        this.releaseLockOnRefresh();\n        this.dispatchDisplayedRowsChanged();\n    }\n\n    private removeRowCompsNotToDraw(indexesToDraw: number[]): void {\n        // for speedy lookup, dump into map\n        const indexesToDrawMap: { [index: string]: boolean; } = {};\n        indexesToDraw.forEach(index => (indexesToDrawMap[index] = true));\n\n        const existingIndexes = Object.keys(this.rowConsByRowIndex);\n        const indexesNotToDraw: string[] = existingIndexes.filter(index => !indexesToDrawMap[index]);\n\n        this.removeRowComps(indexesNotToDraw);\n    }\n\n    private calculateIndexesToDraw(rowsToRecycle?: { [key: string]: RowController; } | null): number[] {\n        // all in all indexes in the viewport\n        const indexesToDraw = createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n\n        const checkRowToDraw = (indexStr: string, rowComp: RowController) => {\n            const index = rowComp.getRowNode().rowIndex;\n            if (index == null) { return; }\n            if (index < this.firstRenderedRow || index > this.lastRenderedRow) {\n                if (this.doNotUnVirtualiseRow(rowComp)) {\n                    indexesToDraw.push(index);\n                }\n            }\n        };\n\n        // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex\n        iterateObject(this.rowConsByRowIndex, checkRowToDraw);\n\n        // if we are redrawing due to model update, then old rows are in rowsToRecycle\n        iterateObject(rowsToRecycle, checkRowToDraw);\n\n        indexesToDraw.sort((a: number, b: number) => a - b);\n\n        return indexesToDraw;\n    }\n\n    private redraw(rowsToRecycle?: { [key: string]: RowController; } | null, animate = false, afterScroll = false) {\n        this.rowContainerHeightService.updateOffset();\n        this.workOutFirstAndLastRowsToRender();\n\n        // the row can already exist and be in the following:\n        // rowsToRecycle -> if model change, then the index may be different, however row may\n        //                         exist here from previous time (mapped by id).\n        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n\n        // this is all the indexes we want, including those that already exist, so this method\n        // will end up going through each index and drawing only if the row doesn't already exist\n        const indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);\n\n        this.removeRowCompsNotToDraw(indexesToDraw);\n\n        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n        // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n        if (this.printLayout) {\n            animate = false;\n        }\n\n        // add in new rows\n        const rowComps: RowController[] = [];\n\n        indexesToDraw.forEach(rowIndex => {\n            const rowComp = this.createOrUpdateRowCon(rowIndex, rowsToRecycle, animate, afterScroll);\n            if (exists(rowComp)) {\n                rowComps.push(rowComp);\n            }\n        });\n\n        if (rowsToRecycle) {\n            const useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n            if (useAnimationFrame) {\n                this.beans.taskQueue.addDestroyTask(() => {\n                    this.destroyRowCons(rowsToRecycle, animate);\n                    this.updateAllRowCons();\n                    this.dispatchDisplayedRowsChanged();\n                });\n            } else {\n                this.destroyRowCons(rowsToRecycle, animate);\n            }\n        }\n\n        this.updateAllRowCons();\n        this.checkAngularCompile();\n        this.gridBodyCon.updateRowCount();\n    }\n\n    private dispatchDisplayedRowsChanged(): void {\n        const event: DisplayedRowsChangedEvent = {type: Events.EVENT_DISPLAYED_ROWS_CHANGED};\n        this.eventService.dispatchEvent(event);\n    }\n\n    private onDisplayedColumnsChanged(): void {\n        const pinningLeft = this.columnController.isPinningLeft();\n        const pinningRight = this.columnController.isPinningRight();\n        const atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n\n        if (atLeastOneChanged) {\n            this.pinningLeft = pinningLeft;\n            this.pinningRight = pinningRight;\n\n            if (this.embedFullWidthRows) {\n                this.redrawFullWidthEmbeddedRows();\n            }\n        }\n    }\n\n    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n    // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n    private redrawFullWidthEmbeddedRows(): void {\n        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n        // embedded, as what appears in each section depends on whether we are pinned or not\n        const rowsToRemove: string[] = [];\n\n        iterateObject(this.rowConsByRowIndex, (id: string, rowComp: RowController) => {\n            if (rowComp.isFullWidth()) {\n                const rowIndex = rowComp.getRowNode().rowIndex;\n\n                rowsToRemove.push(rowIndex!.toString());\n            }\n        });\n\n        this.refreshFloatingRowComps();\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    }\n\n    public refreshFullWidthRows(rowNodesToRefresh?: RowNode[]): void {\n        const rowsToRemove: string[] = [];\n\n        const selectivelyRefreshing = !!rowNodesToRefresh;\n        const idsToRefresh: { [id: string]: boolean; } | undefined = selectivelyRefreshing ? {} : undefined;\n\n        if (selectivelyRefreshing && idsToRefresh) {\n            rowNodesToRefresh!.forEach(r => idsToRefresh[r.id!] = true);\n        }\n\n        iterateObject(this.rowConsByRowIndex, (id: string, rowComp: RowController) => {\n            if (!rowComp.isFullWidth()) { return; }\n\n            const rowNode = rowComp.getRowNode();\n\n            if (selectivelyRefreshing && idsToRefresh) {\n                // we refresh if a) this node is present or b) this parents nodes is present. checking parent\n                // node is important for master/detail, as we want detail to refresh on changes to parent node.\n                // it's also possible, if user is provider their own fullWidth, that details panels contain\n                // some info on the parent, eg if in tree data and child row shows some data from parent row also.\n                const parentId = (rowNode.level > 0 && rowNode.parent) ? rowNode.parent.id : undefined;\n                const skipThisNode = !idsToRefresh[rowNode.id!] && !idsToRefresh[parentId!];\n                if (skipThisNode) { return; }\n            }\n\n            const fullWidthRowsRefreshed = rowComp.refreshFullWidth();\n            if (!fullWidthRowsRefreshed) {\n                const rowIndex = rowComp.getRowNode().rowIndex;\n\n                rowsToRemove.push(rowIndex!.toString());\n            }\n        });\n\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    }\n\n    private createOrUpdateRowCon(\n        rowIndex: number,\n        rowsToRecycle: { [key: string]: RowController | null; } | null | undefined,\n        animate: boolean,\n        afterScroll: boolean\n    ): RowController | null | undefined {\n        let rowNode: RowNode | null = null;\n        let rowCon: RowController | null = this.rowConsByRowIndex[rowIndex];\n\n        // if no row comp, see if we can get it from the previous rowComps\n        if (!rowCon) {\n            rowNode = this.paginationProxy.getRow(rowIndex);\n            if (exists(rowNode) && exists(rowsToRecycle) && rowsToRecycle[rowNode.id!] && rowNode.alreadyRendered) {\n                rowCon = rowsToRecycle[rowNode.id!];\n                rowsToRecycle[rowNode.id!] = null;\n            }\n        }\n\n        const creatingNewRowCon = !rowCon;\n\n        if (creatingNewRowCon) {\n            // create a new one\n            if (!rowNode) {\n                rowNode = this.paginationProxy.getRow(rowIndex);\n            }\n\n            if (exists(rowNode)) {\n                rowCon = this.createRowCon(rowNode, animate, afterScroll);\n            } else {\n                // this should never happen - if somehow we are trying to create\n                // a row for a rowNode that does not exist.\n                return;\n            }\n        }\n\n        if (rowNode) {\n            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n            rowNode.alreadyRendered = true;\n        }\n\n        this.rowConsByRowIndex[rowIndex] = rowCon!;\n\n        return rowCon;\n    }\n\n    private destroyRowCons(rowConsMap: { [key: string]: RowController; } | null | undefined, animate: boolean): void {\n        const executeInAWhileFuncs: (() => void)[] = [];\n        iterateObject(rowConsMap, (nodeId: string, rowCon: RowController) => {\n            // if row was used, then it's null\n            if (!rowCon) { return; }\n\n            rowCon.destroyFirstPass();\n            if (animate) {\n                this.zombieRowCons[rowCon.getInstanceId()] = rowCon;\n                executeInAWhileFuncs.push(() => {\n                    rowCon.destroySecondPass();\n                    delete this.zombieRowCons[rowCon.getInstanceId()];\n                });\n            } else {\n                rowCon.destroySecondPass();\n            }\n        });\n        if (animate) {\n            // this ensures we fire displayedRowsChanged AFTER all the 'executeInAWhileFuncs' get\n            // executed, as we added it to the end of the list.\n            executeInAWhileFuncs.push(() => {\n                this.updateAllRowCons();\n                this.dispatchDisplayedRowsChanged();\n            });\n            executeInAWhile(executeInAWhileFuncs);\n        }\n    }\n\n    private checkAngularCompile(): void {\n        // if we are doing angular compiling, then do digest the scope here\n        if (this.gridOptionsWrapper.isAngularCompileRows()) {\n            // we do it in a timeout, in case we are already in an apply\n            window.setTimeout(() => {\n                this.$scope.$apply();\n            }, 0);\n        }\n    }\n\n    private workOutFirstAndLastRowsToRender(): void {\n        let newFirst: number;\n        let newLast: number;\n\n        if (!this.paginationProxy.isRowsToRender()) {\n            newFirst = 0;\n            newLast = -1; // setting to -1 means nothing in range\n        } else if (this.printLayout) {\n            newFirst = this.paginationProxy.getPageFirstRow();\n            newLast = this.paginationProxy.getPageLastRow();\n        } else {\n            const bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n            const gridBodyCon = this.controllersService.getGridBodyController();\n\n            let rowHeightsChanged = false;\n            let firstPixel: number;\n            let lastPixel: number;\n            do {\n                const paginationOffset = this.paginationProxy.getPixelOffset();\n                const {pageFirstPixel, pageLastPixel} = this.paginationProxy.getCurrentPagePixelRange();\n                const divStretchOffset = this.rowContainerHeightService.getDivStretchOffset();\n\n                const bodyVRange = gridBodyCon.getScrollFeature().getVScrollPosition();\n                const bodyTopPixel = bodyVRange.top;\n                const bodyBottomPixel = bodyVRange.bottom;\n\n                firstPixel = Math.max(bodyTopPixel + paginationOffset - bufferPixels, pageFirstPixel) + divStretchOffset;\n                lastPixel = Math.min(bodyBottomPixel + paginationOffset + bufferPixels, pageLastPixel) + divStretchOffset;\n\n                // if the rows we are about to display get their heights changed, then that upsets the calcs from above.\n                rowHeightsChanged = this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n\n            } while (rowHeightsChanged);\n\n            let firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n            let lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n\n            const pageFirstRow = this.paginationProxy.getPageFirstRow();\n            const pageLastRow = this.paginationProxy.getPageLastRow();\n\n            // adjust, in case buffer extended actual size\n            if (firstRowIndex < pageFirstRow) {\n                firstRowIndex = pageFirstRow;\n            }\n\n            if (lastRowIndex > pageLastRow) {\n                lastRowIndex = pageLastRow;\n            }\n\n            newFirst = firstRowIndex;\n            newLast = lastRowIndex;\n        }\n\n        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n        // killing the browser, we limit the number of rows. just in case some use case we didn't think\n        // of, we also have a property to not do this operation.\n        const rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        const suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n        const rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n\n        if (rowLayoutNormal && !suppressRowCountRestriction) {\n            if (newLast - newFirst > rowBufferMaxSize) {\n                newLast = newFirst + rowBufferMaxSize;\n            }\n        }\n\n        const firstDiffers = newFirst !== this.firstRenderedRow;\n        const lastDiffers = newLast !== this.lastRenderedRow;\n\n        if (firstDiffers || lastDiffers) {\n            this.firstRenderedRow = newFirst;\n            this.lastRenderedRow = newLast;\n\n            const event: ViewportChangedEvent = {\n                type: Events.EVENT_VIEWPORT_CHANGED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            this.eventService.dispatchEvent(event);\n        }\n\n        // only dispatch firstDataRendered if we have actually rendered some data\n        if (this.paginationProxy.isRowsToRender()) {\n            const event: FirstDataRenderedEvent = {\n                type: Events.EVENT_FIRST_DATA_RENDERED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n\n            // added a small delay here because in some scenarios this can be fired\n            // before the grid is actually rendered, causing component creation\n            // on EVENT_FIRST_DATA_RENDERED to fail.\n            window.setTimeout(() => this.eventService.dispatchEventOnce(event), 50);\n        }\n    }\n\n    private ensureAllRowsInRangeHaveHeightsCalculated(topPixel: number, bottomPixel: number): boolean {\n        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n        // all the other row models just hard code so the method just returns back false\n        const res = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n\n        if (res) {\n            this.updateContainerHeights();\n        }\n\n        return res;\n    }\n\n    public getFirstVirtualRenderedRow() {\n        return this.firstRenderedRow;\n    }\n\n    public getLastVirtualRenderedRow() {\n        return this.lastRenderedRow;\n    }\n\n    // check that none of the rows to remove are editing or focused as:\n    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n    //    the edit is reset - so we want to keep it rendered.\n    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n    //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n    //    and then ctrl+c, nothing will happen if cell is removed from dom.\n    // c) if detail record of master detail, as users complained that the context of detail rows\n    //    was getting lost when detail row out of view. eg user expands to show detail row,\n    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n    //    after detail panel is scrolled out of / into view.\n    private doNotUnVirtualiseRow(rowComp: RowController): boolean {\n        const REMOVE_ROW: boolean = false;\n        const KEEP_ROW: boolean = true;\n        const rowNode = rowComp.getRowNode();\n\n        const rowHasFocus = this.focusController.isRowNodeFocused(rowNode);\n        const rowIsEditing = rowComp.isEditing();\n        const rowIsDetail = rowNode.detail;\n\n        const mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;\n\n        // if we deffo don't want to keep it,\n        if (!mightWantToKeepRow) {\n            return REMOVE_ROW;\n        }\n\n        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n        // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n        // the context of the editing in process.\n        const rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n    }\n\n    private createRowCon(rowNode: RowNode, animate: boolean, afterScroll: boolean): RowController {\n        const suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n\n        // we don't use animations frames for printing, so the user can put the grid into print mode\n        // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n        // (via the animation frames) which is awkward to do from code.\n\n        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n        // having animation frames for other times makes the grid look 'jumpy'.\n        const useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n\n        const res = new RowController(\n            this.$scope,\n            rowNode,\n            this.beans,\n            animate,\n            useAnimationFrameForCreate,\n            this.printLayout\n        );\n\n        return res;\n    }\n\n    public getRenderedNodes() {\n        const renderedRows = this.rowConsByRowIndex;\n\n        return Object.keys(renderedRows).map(key => renderedRows[key]!.getRowNode());\n    }\n\n    // we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    public navigateToNextCell(event: KeyboardEvent | null, key: number, currentCell: CellPosition, allowUserOverride: boolean) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        let nextCell: CellPosition | null = currentCell;\n        let hitEdgeOfGrid = false;\n\n        while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === KeyCode.LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            } else if (key === KeyCode.RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            hitEdgeOfGrid = missing(nextCell);\n        }\n\n        if (hitEdgeOfGrid && event && event.keyCode === KeyCode.UP) {\n            nextCell = {\n                rowIndex: -1,\n                rowPinned: null,\n                column: currentCell.column\n            };\n        }\n\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            const userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (exists(userFunc)) {\n                const params: NavigateToNextCellParams = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event\n                };\n                const userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        doOnce(() => { console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    } as CellPosition;\n                } else {\n                    nextCell = null;\n                }\n            }\n        }\n\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) { return; }\n\n        if (nextCell.rowIndex < 0) {\n            const headerLen = this.beans.headerNavigationService.getHeaderRowCount();\n\n            this.focusController.focusHeaderPosition(\n                { headerRowIndex: headerLen + (nextCell.rowIndex), column: currentCell.column }\n            );\n\n            return;\n        }\n\n        // in case we have col spanning we get the cellComp and use it to get the\n        // position. This was we always focus the first cell inside the spanning.\n        const normalisedPosition = this.getNormalisedPosition(nextCell);\n        if (normalisedPosition) {\n            this.focusPosition(normalisedPosition);\n        } else {\n            this.tryToFocusFullWidthRow(nextCell);\n        }\n    }\n\n    private getNormalisedPosition(cellPosition: CellPosition): CellPosition | null {\n        // ensureCellVisible first, to make sure cell at position is rendered.\n        this.ensureCellVisible(cellPosition);\n        const cellComp = this.getComponentForCell(cellPosition);\n\n        // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n        if (!cellComp) { return null; }\n\n        cellPosition = cellComp.getCellPosition();\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(cellPosition);\n\n        return cellPosition;\n    }\n\n    private tryToFocusFullWidthRow(position: CellPosition | RowPosition, backwards: boolean = false): boolean {\n        const displayedColumns = this.columnController.getAllDisplayedColumns();\n        const rowComp = this.getRowConByPosition(position);\n        if (!rowComp || !rowComp.isFullWidth()) { return false; }\n\n        const cellPosition: CellPosition = {\n            rowIndex: position.rowIndex,\n            rowPinned: position.rowPinned,\n            column: (position as CellPosition).column || (backwards ? last(displayedColumns) : displayedColumns[0])\n        };\n\n        this.focusPosition(cellPosition);\n\n        return true;\n    }\n\n    private focusPosition(cellPosition: CellPosition) {\n        this.focusController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n\n        if (this.rangeController) {\n            this.rangeController.setRangeToCell(cellPosition);\n        }\n    }\n\n    private isValidNavigateCell(cell: CellPosition): boolean {\n        const rowNode = this.rowPositionUtils.getRowNode(cell);\n\n        // we do not allow focusing on detail rows and full width rows\n        return !!rowNode;\n    }\n\n    private getLastCellOfColSpan(cell: CellPosition): CellPosition {\n        const cellComp = this.getComponentForCell(cell);\n\n        if (!cellComp) { return cell; }\n\n        const colSpanningList = cellComp.getColSpanningList();\n\n        if (colSpanningList.length === 1) { return cell; }\n\n        return {\n            rowIndex: cell.rowIndex,\n            column: last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    }\n\n    public ensureCellVisible(gridCell: CellPosition): void {\n        // this scrolls the row into view\n        if (missing(gridCell.rowPinned)) {\n            this.gridBodyCon.getScrollFeature().ensureIndexVisible(gridCell.rowIndex);\n        }\n\n        if (!gridCell.column.isPinned()) {\n            this.gridBodyCon.getScrollFeature().ensureColumnVisible(gridCell.column);\n        }\n\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridBodyCon.getScrollFeature().horizontallyScrollHeaderCenterAndFloatingCenter();\n\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    }\n\n    public startEditingCell(gridCell: CellPosition, keyPress?: number | null, charPress?: string | null): void {\n        const cell = this.getComponentForCell(gridCell);\n        if (cell) {\n            cell.startRowOrCellEdit(keyPress, charPress);\n        }\n    }\n\n    public getRowConByPosition(rowPosition: RowPosition): RowController | null {\n        let rowComponent: RowController | null;\n        switch (rowPosition.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowComponent = this.topRowCons[rowPosition.rowIndex];\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowComponent = this.bottomRowCons[rowPosition.rowIndex];\n                break;\n            default:\n                rowComponent = this.rowConsByRowIndex[rowPosition.rowIndex];\n                break;\n        }\n\n        return rowComponent;\n    }\n\n    public getComponentForCell(cellPosition: CellPosition): CellComp | null {\n        const rowComp = this.getRowConByPosition(cellPosition);\n\n        if (!rowComp) {\n            return null;\n        }\n\n        const cellComponent =  rowComp.getRenderedCellForColumn(cellPosition.column);\n\n        return cellComponent;\n    }\n\n    public getRowNode(gridRow: RowPosition): RowNode | null {\n        switch (gridRow.rowPinned) {\n            case Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    }\n\n    // result of keyboard event\n    public onTabKeyDown(previousRenderedCell: CellComp | RowController, keyboardEvent: KeyboardEvent): void {\n        const backwards = keyboardEvent.shiftKey;\n        const movedToNextCell = this.tabToNextCellCommon(previousRenderedCell, backwards);\n\n        if (movedToNextCell) {\n            // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n            // to the normal tabbing so user can exit the grid.\n            keyboardEvent.preventDefault();\n            return;\n        }\n\n        // if we didn't move to next cell, then need to tab out of the cells, ie to the header (if going\n        // backwards)\n        if (backwards) {\n            const { rowIndex, rowPinned } = previousRenderedCell.getRowPosition();\n            const firstRow = rowPinned ? rowIndex === 0 : rowIndex === this.paginationProxy.getPageFirstRow();\n            if (firstRow) {\n                keyboardEvent.preventDefault();\n\n                const headerRowIndex = this.beans.headerNavigationService.getHeaderRowCount() - 1;\n                const column = last(this.columnController.getAllDisplayedColumns());\n\n                this.focusController.focusHeaderPosition({ headerRowIndex, column });\n            }\n        } else {\n            // if the case it's a popup editor, the focus is on the editor and not the previous cell.\n            // in order for the tab navigation to work, we need to focus the browser back onto the\n            // previous cell.\n            if (previousRenderedCell instanceof CellComp) {\n                previousRenderedCell.focusCell(true);\n            }\n\n            if (this.focusController.focusNextGridCoreContainer(false)) {\n                keyboardEvent.preventDefault();\n            }\n        }\n    }\n\n    // comes from API\n    public tabToNextCell(backwards: boolean): boolean {\n        const focusedCell = this.focusController.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (!focusedCell) { return false; }\n\n        let cellOrRowComp: CellComp | RowController | null = this.getComponentForCell(focusedCell);\n\n        // if cell is not rendered, means user has scrolled away from the cell\n        // or that the focusedCell is a Full Width Row\n        if (!cellOrRowComp) {\n            cellOrRowComp = this.getRowConByPosition(focusedCell);\n            if (!cellOrRowComp || !cellOrRowComp.isFullWidth()) {\n                return false;\n            }\n        }\n\n        return this.tabToNextCellCommon(cellOrRowComp, backwards);\n    }\n\n    private tabToNextCellCommon(previousCellOrRow: CellComp | RowController, backwards: boolean): boolean {\n        let editing = previousCellOrRow.isEditing();\n\n        // if cell is not editing, there is still chance row is editing if it's Full Row Editing\n        if (!editing && previousCellOrRow instanceof CellComp) {\n            const cellComp = previousCellOrRow as CellComp;\n            const rowCon = cellComp.getRenderedRow();\n            if (rowCon) {\n                editing = rowCon.isEditing();\n            }\n        }\n\n        let res: boolean;\n\n        if (editing) {\n            // if we are editing, we know it's not a Full Width Row (RowComp)\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previousCellOrRow as CellComp, backwards);\n            } else {\n                res = this.moveToNextEditingCell(previousCellOrRow as CellComp, backwards);\n            }\n        } else {\n            res = this.moveToNextCellNotEditing(previousCellOrRow, backwards);\n        }\n\n        // if a cell wasn't found, it's possible that focus was moved to the header\n        return res || !!this.focusController.getFocusedHeader();\n    }\n\n    private moveToNextEditingCell(previousRenderedCell: CellComp, backwards: boolean): boolean {\n        const gridCell = previousRenderedCell.getCellPosition();\n\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousRenderedCell.stopEditing();\n\n        // find the next cell to start editing\n        const nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true) as CellComp;\n        const foundCell = nextRenderedCell != null;\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.startEditingIfEnabled(null, null, true);\n            nextRenderedCell.focusCell(false);\n        }\n\n        return foundCell;\n    }\n\n    private moveToNextEditingRow(previousCellComp: CellComp, backwards: boolean): boolean {\n        const cellPos = previousCellComp.getCellPosition();\n        // find the next cell to start editing\n        const nextCellComp = this.findNextCellToFocusOn(cellPos, backwards, true) as CellComp;\n\n        if (nextCellComp == null) { return false; }\n\n        const previousPos = previousCellComp.getCellPosition();\n        const nextPos = nextCellComp.getCellPosition();\n\n        const previousEditable = this.isCellEditable(previousPos);\n        const nextEditable = this.isCellEditable(nextPos);\n\n        const rowsMatch = nextPos && previousPos.rowIndex === nextPos.rowIndex && previousPos.rowPinned === nextPos.rowPinned;\n\n        if (previousEditable) {\n            previousCellComp.setFocusOutOnEditor();\n        }\n\n        if (!rowsMatch) {\n            const pRow = previousCellComp.getRenderedRow();\n            pRow!.stopEditing();\n\n            const nRow = nextCellComp.getRenderedRow();\n            nRow!.startRowEditing();\n        }\n\n        if (nextEditable) {\n            nextCellComp.setFocusInOnEditor();\n            nextCellComp.focusCell();\n        } else {\n            nextCellComp.focusCell(true);\n        }\n\n        return true;\n    }\n\n    private moveToNextCellNotEditing(previousRenderedCell: CellComp | RowController, backwards: boolean): boolean {\n        const displayedColumns = this.columnController.getAllDisplayedColumns();\n        let gridCell: CellPosition;\n\n        if (previousRenderedCell instanceof RowController) {\n            gridCell = {\n                ...previousRenderedCell.getRowPosition(),\n                column: backwards ? displayedColumns[0] : last(displayedColumns)\n            };\n        } else {\n            gridCell = previousRenderedCell.getCellPosition();\n        }\n        // find the next cell to start editing\n        const nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, false);\n\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (nextRenderedCell instanceof CellComp) {\n            nextRenderedCell.focusCell(true);\n        } else if (nextRenderedCell) {\n            return this.tryToFocusFullWidthRow(nextRenderedCell.getRowPosition(), backwards);\n        }\n\n        return exists(nextRenderedCell);\n    }\n\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    private findNextCellToFocusOn(gridCell: CellPosition, backwards: boolean, startEditing: boolean): CellComp | RowController | null {\n        let nextCell: CellPosition | null = gridCell;\n\n        while (true) {\n            if (!backwards) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards);\n\n            // allow user to override what cell to go to next\n            const userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n\n            if (exists(userFunc)) {\n                const params = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: gridCell,\n                    nextCellPosition: nextCell ? nextCell : null\n                } as TabToNextCellParams;\n                const userCell = userFunc(params);\n                if (exists(userCell)) {\n                    if ((userCell as any).floating) {\n                        doOnce(() => { console.warn(`AG Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?`); }, 'no floating in userCell');\n                        userCell.rowPinned = (userCell as any).floating;\n                    }\n                    nextCell = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    } as CellPosition;\n                } else {\n                    nextCell = null;\n                }\n            }\n\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextCell) { return null; }\n\n            if (nextCell.rowIndex < 0) {\n                const headerLen = this.beans.headerNavigationService.getHeaderRowCount();\n\n                this.focusController.focusHeaderPosition(\n                    { headerRowIndex: headerLen + (nextCell.rowIndex), column: nextCell.column }\n                );\n\n                return null;\n            }\n\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            // note - for full row edit, we do focus non-editable cells, as the row stays in edit mode.\n            const fullRowEdit = this.gridOptionsWrapper.isFullRowEdit();\n            if (startEditing && !fullRowEdit) {\n                const cellIsEditable = this.isCellEditable(nextCell);\n                if (!cellIsEditable) { continue; }\n            }\n\n            this.ensureCellVisible(nextCell);\n\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            const nextCellComp = this.getComponentForCell(nextCell);\n\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (!nextCellComp) {\n                const rowComp = this.getRowConByPosition(nextCell);\n                if (!rowComp || !rowComp.isFullWidth()) {\n                    continue;\n                } else {\n                    return rowComp;\n                }\n            }\n\n            if (nextCellComp.isSuppressNavigable()) { continue; }\n\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeController) {\n                this.rangeController.setRangeToCell(nextCell);\n            }\n\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCellComp;\n        }\n    }\n\n    private isCellEditable(cell: CellPosition): boolean {\n        const rowNode = this.lookupRowNodeForCell(cell);\n\n        if (rowNode) {\n            return cell.column.isCellEditable(rowNode);\n        }\n\n        return false;\n    }\n\n    private lookupRowNodeForCell(cell: CellPosition) {\n        if (cell.rowPinned === Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n\n        if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n\n        return this.paginationProxy.getRow(cell.rowIndex);\n    }\n\n    // returns true if any row between startIndex and endIndex is rendered. used by\n    // SSRM or IRM, as they don't want to purge visible blocks from cache.\n    public isRangeInRenderedViewport(startIndex: number, endIndex: number): boolean {\n\n        // parent closed means the parent node is not expanded, thus these blocks are not visible\n        const parentClosed = startIndex == null || endIndex == null;\n        if (parentClosed) { return false; }\n\n        const blockAfterViewport = startIndex > this.lastRenderedRow;\n        const blockBeforeViewport = endIndex < this.firstRenderedRow;\n        const blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;\n\n        return blockInsideViewport;\n    }\n}\n\nexport interface RefreshViewParams {\n    recycleRows?: boolean;\n    animate?: boolean;\n    suppressKeepFocus?: boolean;\n    onlyBody?: boolean;\n    // when new data, grid scrolls back to top\n    newData?: boolean;\n    newPage?: boolean;\n}\n"]}